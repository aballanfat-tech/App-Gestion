<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Import Factures</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#fafafa; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 18px; background:#fff; border-bottom:1px solid #e5e5e5; position:sticky; top:0; z-index:100; flex-wrap:wrap; }
    .btn { cursor:pointer; border:1px solid #ddd; background:#fff; padding:10px 12px; border-radius:10px; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    main { max-width: 980px; margin: 18px auto; padding: 0 14px; }
    .card { background:#fff; border:1px solid #e5e5e5; border-radius:14px; padding:14px; margin-bottom:14px; }
    .drop { border:2px dashed #bbb; border-radius:14px; padding:22px; text-align:center; background:#fcfcfc; }
    .drop.drag { border-color:#333; background:#fff; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #eee; padding:10px 8px; text-align:left; font-size:14px; vertical-align:top; }
    th { font-size:12px; text-transform:uppercase; letter-spacing:.04em; color:#666; }
    .pill { display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; }
    .ok { border-color:#9ad39a; }
    .err { border-color:#ffb3b3; }
    .muted { color:#666; font-size:13px; }
    .row-actions { display:flex; gap:8px; flex-wrap:wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }
    .notice { background:#fff7d6; border:1px solid #f1d88a; padding:10px 12px; border-radius:12px; margin-bottom:14px; }
    .small { font-size:12px; }
    input[type="file"] { max-width: 100%; }
    .field { border:1px solid #ddd; border-radius:10px; padding:10px 12px; background:#fff; }
    .authBox { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .msg { padding:10px 12px; border-radius:12px; border:1px solid #e5e5e5; background:#fff; }
    .msg.ok { border-color:#9ad39a; background:#f2fff2; }
    .msg.err { border-color:#ffb3b3; background:#fff2f2; }
    .msg.warn { border-color:#f1d88a; background:#fff7d6; }

    mark.hl { background:#ffe58f; padding:0 2px; border-radius:4px; }
    .hlBox { display:flex; gap:10px; flex-wrap:wrap; padding:10px 12px; border:1px solid #eee; border-radius:12px; background:#fafafa; margin:10px 0; }
    .hlTag { border:1px solid #ddd; border-radius:999px; padding:4px 8px; font-size:12px; background:#fff; }

    #textModal { display:none; pointer-events:none; z-index: 9999; }
    #textModal.open { display:flex !important; pointer-events:auto; }

    .tablePdf {
      width:100%;
      border-collapse: collapse;
      font-size:13px;
      background:#fff;
      border:1px solid #eee;
      border-radius:12px;
      overflow:hidden;
    }
    .tablePdf th, .tablePdf td {
      border-bottom:1px solid #eee;
      padding:8px 10px;
      vertical-align:top;
      white-space:nowrap;
    }
    .tablePdf td.desc { white-space:normal; min-width:420px; }
    .tablePdf th { background:#f7f7f7; font-size:12px; text-transform:uppercase; letter-spacing:.03em; }
    .rowDebours td { background:#fff7d6; font-weight:600; }

    /* ‚úÖ Sous-trajets UI */
    .subTripsWrap {
      display:none;
      padding:10px 12px;
      background:#fafafa;
      border:1px solid #eee;
      border-radius:12px;
      margin:8px 0 12px 0;
    }
    .subTripsWrap.open { display:block; }
    .subTripsTitle { font-weight:700; margin-bottom:8px; }
    .subTable {
      width:100%;
      border-collapse:collapse;
      font-size:12px;
      background:#fff;
      border:1px solid #eee;
      border-radius:10px;
      overflow:hidden;
    }
    .subTable th, .subTable td {
      border-bottom:1px solid #eee;
      padding:6px 8px;
      vertical-align:top;
    }
    .subTable th {
      background:#f7f7f7;
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.03em;
      color:#666;
    }
    .btnSmall {
      border:1px solid #ddd;
      background:#fff;
      padding:6px 8px;
      border-radius:10px;
      cursor:pointer;
      font-size:12px;
    }
    .btnSmall:disabled { opacity:.5; cursor:not-allowed; }

    /* ‚úÖ TRI 3 DESTINATIONS */
    .triWrap {
      margin-top:12px;
      padding:12px;
      background:#fff;
      border:1px solid #eee;
      border-radius:12px;
    }
    .triTitle { font-weight:800; margin-bottom:10px; }
    .triCols {
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
    }
    .triCol {
      border:1px solid #e5e5e5;
      border-radius:12px;
      padding:10px;
      background:#fafafa;
      min-height:160px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .triHead {
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
    }
    .triName {
      width:100%;
      border:1px solid #ddd;
      border-radius:10px;
      padding:7px 8px;
      font-size:12px;
      background:#fff;
    }
    .triDrop {
      flex:1;
      border:2px dashed #cfcfcf;
      border-radius:12px;
      padding:8px;
      background:#fff;
      min-height:90px;
    }
    .triDrop.dragOver { border-color:#333; background:#f8f8ff; }
    .triItem {
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:8px;
      border:1px solid #eee;
      border-radius:10px;
      padding:7px 8px;
      background:#fff;
      cursor:grab;
      user-select:none;
    }
    .triItem .left { display:flex; flex-direction:column; gap:2px; }
    .triItem .h { font-weight:800; font-size:12px; }
    .triItem .t { font-size:12px; color:#333; }
    .triItem .p { font-size:12px; color:#666; white-space:nowrap; }
    .triItem .rm { border:1px solid #ddd; background:#fff; border-radius:10px; padding:4px 6px; cursor:pointer; font-size:11px; }
    .triFooter {
      margin-top:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .triPrices {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .triPrices input {
      width:110px;
      border:1px solid #ddd;
      border-radius:10px;
      padding:7px 8px;
      font-size:12px;
      background:#fff;
    }
    .triNote { font-size:12px; color:#666; }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>

<body>
<header>
  <div style="display:flex; align-items:center; gap:10px;">
    <button class="btn" id="backBtn">‚¨ÖÔ∏è Retour</button>
    <strong>üì§ Import Factures (V2.4 ‚Äì Tri 3 Destinations)</strong>
  </div>

  <div class="authBox">
    <span class="muted" id="authStatus">Connexion‚Ä¶</span>
    <input class="field" id="emailInput" type="email" placeholder="Email" style="min-width:220px;">
    <input class="field" id="passInput" type="password" placeholder="Mot de passe" style="min-width:160px;">
    <button class="btn" id="loginBtn">Se connecter</button>
    <button class="btn" id="logoutBtn" disabled>Se d√©connecter</button>
  </div>
</header>

<main>
  <div class="notice">
    <div><strong>But :</strong> tu r√©partis manuellement les sous-trajets dans 3 destinations, puis tu saisis le prix par destination.</div>
    <div class="muted small">‚úÖ V2.4 ‚Ä¢ ‚úÖ Drag&Drop tri 3 destinations ‚Ä¢ ‚úÖ Save dans donnees_brutes.lines[].tri</div>
  </div>

  <div id="globalMsg" class="msg warn" style="display:none; margin-bottom:14px;"></div>

  <div class="card">
    <div class="drop" id="dropZone">
      <div style="font-size:18px; margin-bottom:6px;">Glisse-d√©pose tes PDFs ici</div>
      <div class="muted">PDF uniquement ‚Ä¢ max 10 MB/fichier ‚Ä¢ max 20 fichiers</div>
      <div style="margin-top:12px;">
        <input type="file" id="fileInput" accept="application/pdf" multiple />
      </div>
    </div>
    <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
      <button class="btn" id="startUploadBtn" disabled>üöÄ Uploader & Traiter</button>
      <button class="btn" id="clearBtn" disabled>üßπ Vider la liste</button>
    </div>
  </div>

  <div class="card">
    <div style="display:flex; align-items:center; justify-content:space-between;">
      <strong>üìÑ Fichiers s√©lectionn√©s</strong>
      <span class="muted" id="selectedCount">0</span>
    </div>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
        <tr>
          <th>Fichier</th>
          <th>Taille</th>
          <th>Statut</th>
          <th>Facture ID</th>
          <th>Actions</th>
        </tr>
        </thead>
        <tbody id="filesTbody">
        <tr><td colspan="5" class="muted">Aucun fichier</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</main>

<div id="textModal" style="
  position:fixed; inset:0; background:rgba(0,0,0,.5);
  align-items:center; justify-content:center; padding:18px;">
  <div style="
    width:min(1100px, 96vw); max-height:88vh; background:#fff; border-radius:14px;
    border:1px solid #e5e5e5; overflow:hidden; display:flex; flex-direction:column;">
    <div style="display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid #eee;">
      <strong>üßæ Viewer (Texte + Tableau + Tri)</strong>
      <div style="display:flex; gap:8px;">
        <button class="btn" id="copyTextBtn">üìã Copier</button>
        <button class="btn" id="closeTextBtn">‚úñ Fermer</button>
      </div>
    </div>
    <div style="padding:12px 14px; overflow:auto;">
      <div class="muted" id="textMeta" style="margin-bottom:10px;"></div>
      <div id="hlBox" class="hlBox"></div>

      <div style="display:flex; gap:8px; margin-bottom:10px;">
        <button class="btn" id="tabTextBtn">üü¶ Texte</button>
        <button class="btn" id="tabTableBtn">üü© Tableau</button>
      </div>

      <div id="tableWrap" style="display:none;">
        <div class="muted small" style="margin-bottom:8px;">
          Tableau reconstruit depuis X/Y PDF. Debug : donnees_brutes.table_debug.
        </div>
        <div id="tableContent" style="overflow:auto;"></div>
      </div>

      <div id="textWrap">
        <div id="textContent" style="
          white-space:pre-wrap; word-break:break-word;
          background:#fafafa; border:1px solid #eee; border-radius:12px;
          padding:12px; font-size:13px; line-height:1.35;"></div>
      </div>
    </div>
  </div>
</div>

<script src="./supabase-core.js"></script>
<script src="./supabase-services.js"></script>

<script>
  // ------------------------------------------------------------
  // Globals / DOM
  // ------------------------------------------------------------
  const MAX_FILES = 20;
  const MAX_SIZE = 10 * 1024 * 1024;
  let sb = null;

  const state = { files: [] };

  const dropZone = document.getElementById("dropZone");
  const fileInput = document.getElementById("fileInput");
  const startUploadBtn = document.getElementById("startUploadBtn");
  const clearBtn = document.getElementById("clearBtn");
  const filesTbody = document.getElementById("filesTbody");
  const selectedCount = document.getElementById("selectedCount");

  const authStatus = document.getElementById("authStatus");
  const loginBtn = document.getElementById("loginBtn");
  const logoutBtn = document.getElementById("logoutBtn");
  const emailInput = document.getElementById("emailInput");
  const passInput = document.getElementById("passInput");

  // Viewer refs
  const textModal = document.getElementById("textModal");
  const closeTextBtn = document.getElementById("closeTextBtn");
  const copyTextBtn = document.getElementById("copyTextBtn");
  const textMeta = document.getElementById("textMeta");
  const tabTextBtn = document.getElementById("tabTextBtn");
  const tabTableBtn = document.getElementById("tabTableBtn");
  const textWrap = document.getElementById("textWrap");
  const tableWrap = document.getElementById("tableWrap");
  const tableContent = document.getElementById("tableContent");
  const textContent = document.getElementById("textContent");
  const hlBox = document.getElementById("hlBox");

  document.getElementById("backBtn").onclick = () => window.location.href = "index.html";

  // Viewer context
  let viewerFactureId = null;
  let viewerDonneesBrutes = null;
  let viewerServiceLines = []; // structured lines array (type service)

  // ------------------------------------------------------------
  // UI Helpers
  // ------------------------------------------------------------
  function setMsg(type, text) {
    const box = document.getElementById("globalMsg");
    box.className = "msg " + (type || "warn");
    box.textContent = text || "";
    box.style.display = text ? "block" : "none";
  }

  function formatBytes(bytes) {
    if (bytes < 1024) return bytes + " B";
    const kb = bytes / 1024;
    if (kb < 1024) return kb.toFixed(1) + " KB";
    return (kb / 1024).toFixed(1) + " MB";
  }

  function isPdf(file) {
    return file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
  }
  function sanitizeFilename(name) {
    return name.replace(/[^a-zA-Z0-9.\-_]/g, "_").replace(/_{2,}/g, "_");
  }

  function escapeHtml(s) {
    return (s || "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  // ------------------------------------------------------------
  // Modal
  // ------------------------------------------------------------
  function closeModal() {
    textModal.classList.remove("open");
    textContent.innerHTML = "";
    tableContent.innerHTML = "";
    hlBox.innerHTML = "";
    viewerFactureId = null;
    viewerDonneesBrutes = null;
    viewerServiceLines = [];
  }
  closeTextBtn.onclick = closeModal;
  textModal.addEventListener("click", (e) => { if (e.target === textModal) closeModal(); });

  copyTextBtn.onclick = async () => {
    await navigator.clipboard.writeText(textContent.textContent || "");
    copyTextBtn.textContent = "‚úÖ Copi√©";
    setTimeout(() => copyTextBtn.textContent = "üìã Copier", 900);
  };

  function setTab(which) {
    if (which === "text") { textWrap.style.display = "block"; tableWrap.style.display = "none"; }
    else { textWrap.style.display = "none"; tableWrap.style.display = "block"; }
  }
  tabTextBtn.onclick = () => setTab("text");
  tabTableBtn.onclick = () => setTab("table");

  // ------------------------------------------------------------
  // Highlight stable
  // ------------------------------------------------------------
  function highlightText(rawText, highlights) {
    if (!rawText) return "‚ö†Ô∏è Aucun texte.";

    function normalizeWithMap(s) {
      const map = [];
      let norm = "";
      let lastWasSpace = false;

      for (let i = 0; i < s.length; i++) {
        let c = s[i];
        if (c === "‚Äô") c = "'";
        if (/\s/.test(c)) {
          if (lastWasSpace) continue;
          c = " ";
          lastWasSpace = true;
        } else lastWasSpace = false;

        norm += c.toLowerCase();
        map.push(i);
      }
      return { norm, map };
    }

    const { norm: normText, map } = normalizeWithMap(rawText);
    const ranges = [];

    const sorted = [...highlights]
      .filter(h => h?.value && String(h.value).trim().length >= 3)
      .sort((a,b) => String(b.value).length - String(a.value).length);

    for (const h of sorted) {
      const tokenRaw = String(h.value).trim().replace(/‚Äô/g, "'");
      const { norm: normToken } = normalizeWithMap(tokenRaw);

      let from = 0;
      while (true) {
        const idx = normText.indexOf(normToken, from);
        if (idx === -1) break;

        const startOrig = map[idx];
        const endOrig = map[Math.min(idx + normToken.length - 1, map.length - 1)] + 1;

        ranges.push({ start: startOrig, end: endOrig, label: h.label || "" });
        from = idx + normToken.length;
      }
    }

    if (ranges.length === 0) return escapeHtml(rawText);

    ranges.sort((a,b) => a.start - b.start || b.end - a.end);
    const merged = [];
    for (const r of ranges) {
      const last = merged[merged.length - 1];
      if (!last || r.start >= last.end) merged.push(r);
      else if (r.end > last.end) last.end = r.end;
    }

    let out = "";
    let pos = 0;
    for (const r of merged) {
      out += escapeHtml(rawText.slice(pos, r.start));
      out += `<mark class="hl" title="${escapeHtml(r.label)}">${escapeHtml(rawText.slice(r.start, r.end))}</mark>`;
      pos = r.end;
    }
    out += escapeHtml(rawText.slice(pos));
    return out;
  }

  function renderHighlightsBox(data) {
    const tags = [];
    if (data.numero_facture) tags.push(`<span class="hlTag"># ${escapeHtml(String(data.numero_facture))}</span>`);
    if (data.date_facture) tags.push(`<span class="hlTag">üìÖ ${escapeHtml(String(data.date_facture))}</span>`);
    if (data.client_nom) tags.push(`<span class="hlTag">üë§ ${escapeHtml(String(data.client_nom))}</span>`);
    if (typeof data.total_ht === "number") tags.push(`<span class="hlTag">HT ${escapeHtml(String(data.total_ht))}</span>`);
    if (typeof data.total_ttc === "number") tags.push(`<span class="hlTag">TTC ${escapeHtml(String(data.total_ttc))}</span>`);
    hlBox.innerHTML = tags.length ? tags.join(" ") : `<span class="muted">Aucune donn√©e structur√©e d√©tect√©e.</span>`;
  }

  function buildHighlightsFromDB(data) {
    const hl = [];
    if (data.numero_facture) hl.push({ label:"Num√©ro facture", value:String(data.numero_facture) });
    if (data.client_nom) hl.push({ label:"Client", value:String(data.client_nom) });

    const matches = data?.donnees_brutes?.matches || [];
    for (const m of matches) {
      if (!m?.value) continue;
      hl.push({ label: m.label, value: String(m.value) });
    }

    const seen = new Set();
    return hl.filter(x => {
      const key = x.label + "::" + x.value;
      if (seen.has(key)) return false;
      seen.add(key);
      return (x.value || "").trim().length >= 3;
    });
  }

  // ------------------------------------------------------------
  // Parsing helpers
  // ------------------------------------------------------------
  function normalizeNumber(str) {
    if (!str) return null;
    const n = str.replace(/\s/g, "").replace(",", ".");
    const val = parseFloat(n.replace(/[^0-9.]/g, ""));
    return Number.isFinite(val) ? val : null;
  }

  function parsePercent(str) {
    if (!str) return null;
    const m = str.match(/(\d{1,3})\s*%/);
    return m ? parseInt(m[1], 10) : null;
  }

  function parseFrenchDateAny(dateStr) {
    if (!dateStr) return null;

    const mNum = dateStr.match(/(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})/);
    if (mNum) {
      let d = parseInt(mNum[1],10), mo = parseInt(mNum[2],10), y = parseInt(mNum[3],10);
      if (y < 100) y += 2000;
      return `${y.toString().padStart(4,"0")}-${mo.toString().padStart(2,"0")}-${d.toString().padStart(2,"0")}`;
    }

    const months = {
      "janvier":1, "f√©vrier":2, "fevrier":2, "mars":3, "avril":4, "mai":5, "juin":6,
      "juillet":7, "ao√ªt":8, "aout":8, "septembre":9, "octobre":10, "novembre":11,
      "d√©cembre":12, "decembre":12
    };

    const mTxt = dateStr.toLowerCase().match(/(\d{1,2})\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+(\d{4})/);
    if (mTxt) {
      const d = parseInt(mTxt[1],10);
      const mo = months[mTxt[2]];
      const y = parseInt(mTxt[3],10);
      if (!mo) return null;
      return `${y.toString().padStart(4,"0")}-${String(mo).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
    }
    return null;
  }

  function splitSourceDest(desc) {
    let source = null, destination = null;
    const mFromTo = desc.match(/de\s+(.+?)\s+√†\s+(.+)/i);
    if (mFromTo) { source = mFromTo[1].trim(); destination = mFromTo[2].trim(); }
    const mArrow = desc.match(/(.+?)\s*(?:=>|>\s*=>?|=\s*>)\s*(.+)/);
    if (mArrow) { source = source || mArrow[1].trim(); destination = destination || mArrow[2].trim(); }
    return { source_lieu: source, destination_lieu: destination };
  }

  // ------------------------------------------------------------
  // ‚úÖ Extract sub-trips (hours chunks)
  // ------------------------------------------------------------
  function extractSubTrips(desc) {
    if (!desc) return [];
    const txt = String(desc).replace(/\s+/g, " ").trim();
    const re = /(\b\d{1,2}h\d{2}\b)\s+(.+?)(?=(\b\d{1,2}h\d{2}\b)|$)/g;
    const trips = [];
    let m;

    while ((m = re.exec(txt)) !== null) {
      const heure = m[1];
      let chunk = (m[2] || "").replace(/\s+/g, " ").trim();

      let pax = null;
      const mp = chunk.match(/\bx?\s*(\d{1,3})\s*(pax|pers|personnes)\b/i);
      if (mp) pax = parseInt(mp[1], 10);
      if (mp) chunk = chunk.replace(mp[0], "").replace(/\s+/g, " ").trim();
      if (chunk.length < 2) chunk = "";

      trips.push({ heure, texte: chunk, pax });
    }
    return trips;
  }

  // ------------------------------------------------------------
  // Client clean
  // ------------------------------------------------------------
  function cleanClientName(raw) {
    if (!raw) return null;
    let s = String(raw).replace(/\s+/g, " ").trim();

    const stopMarkers = [" Conditions", " Adresse", " Pays", " Num√©ro", " Numero", " TVA", " S√©jours", " D√©tail", " Detail"];
    for (const m of stopMarkers) {
      const idx = s.indexOf(m);
      if (idx > 2) { s = s.slice(0, idx).trim(); break; }
    }

    s = s.replace(/\b(CS|BP)\b[\s\S]*$/i, "").trim();
    s = s.replace(/\bCEDEX\b[\s\S]*$/i, "").trim();

    s = s.replace(/\b\d+\s*(bis|ter)?\s+(rue|route|avenue|av\.?|all√©e|allee|chemin|cours|boulevard|bd|place|impasse|za|zone|mont√©e|montee|mont|quai|passage)\b[\s\S]*$/i, "").trim();

    s = s.replace(/\b\d{5}\b[\s\S]*$/g, "").trim();
    s = s.replace(/\b(France|Belgique|Suisse|Luxembourg)\b[\s\S]*$/i, "").trim();

    const parts = s.split(" ");
    if (parts.length > 2) {
      const mid = Math.floor(parts.length / 2);
      const left = parts.slice(0, mid).join(" ");
      const right = parts.slice(mid).join(" ");
      if (left.trim() === right.trim()) s = left.trim();
    }

    s = s.replace(/[,;:\-]+$/g, "").trim();
    return s.length >= 2 ? s : null;
  }

  // ------------------------------------------------------------
  // Parse invoice fields
  // ------------------------------------------------------------
  function parseInvoiceText(fullText) {
    const out = { version:"parser_table_v24", parsed_at:new Date().toISOString(), fields:{}, matches:[] };
    const t = fullText || "";

    const mFact = t.match(/\bFacture\s+([A-Z]{2,6}-\d{3,4}-\d{2,})\b/i) || t.match(/\bFACT-\d{4}-\d{2,}\b/);
    if (mFact) {
      const val = (mFact[1] || mFact[0]).trim();
      out.fields.numero_facture = val;
      out.matches.push({ label:"numero_facture", value: val, raw: mFact[0] });
    }

    const mDateTxt = t.match(/\b(\d{1,2}\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+\d{4})\b/i);
    if (mDateTxt) {
      const rawDate = mDateTxt[1].trim();
      const iso = parseFrenchDateAny(rawDate);
      if (iso) {
        out.fields.date_facture = iso;
        out.matches.push({ label:"date_facture", value: rawDate, raw: rawDate });
      }
    }

    const mDest = t.match(/Destinataire\s+([\s\S]+?)\s+(Conditions|S√©jours|D√©tail|Detail)/i);
    if (mDest) {
      const rawClientBlock = mDest[1].replace(/\s+/g," ").trim();
      const clean = cleanClientName(rawClientBlock);
      if (clean) {
        out.fields.client_nom = clean;
        out.matches.push({ label:"client_nom", value: clean, raw: rawClientBlock });
      }
    }

    const mTotals1 = t.match(/Total\s*HT\s+TVA\s*\(\s*\d+%\s*\)\s+Total\s*TTC\s+([0-9\s.,]+)\s*‚Ç¨?\s+([0-9\s.,]+)\s*‚Ç¨?\s+([0-9\s.,]+)\s*‚Ç¨/i);
    if (mTotals1) {
      out.fields.total_ht = normalizeNumber(mTotals1[1]);
      out.fields.total_tva = normalizeNumber(mTotals1[2]);
      out.fields.total_ttc = normalizeNumber(mTotals1[3]);
      out.matches.push({ label:"total_ht", value: mTotals1[1], raw: mTotals1[0] });
      out.matches.push({ label:"total_tva", value: mTotals1[2], raw: mTotals1[0] });
      out.matches.push({ label:"total_ttc", value: mTotals1[3], raw: mTotals1[0] });
      return out;
    }

    const mHT = t.match(/Total\s*HT\s*[:\s]\s*([0-9\s.,]+)\s*‚Ç¨/i);
    const mTVA = t.match(/\bTVA\s*[:\s]\s*([0-9\s.,]+)\s*‚Ç¨/i);
    const mTTC = t.match(/Total\s*TTC\s*[:\s]\s*([0-9\s.,]+)\s*‚Ç¨/i);
    if (mHT) { out.fields.total_ht = normalizeNumber(mHT[1]); out.matches.push({ label:"total_ht", value:mHT[1], raw:mHT[0] }); }
    if (mTVA) { out.fields.total_tva = normalizeNumber(mTVA[1]); out.matches.push({ label:"total_tva", value:mTVA[1], raw:mTVA[0] }); }
    if (mTTC) { out.fields.total_ttc = normalizeNumber(mTTC[1]); out.matches.push({ label:"total_ttc", value:mTTC[1], raw:mTTC[0] }); }

    return out;
  }

  // ------------------------------------------------------------
  // Table detector (identique V2.3)
  // ------------------------------------------------------------
  function groupItemsIntoLines(items, baseTolerance = 3.2) {
    const sorted = [...items].sort((a,b) => b.y - a.y);
    const lines = [];
    for (const it of sorted) {
      const tol = Math.max(baseTolerance, (it.h || 0) * 0.35);
      let line = lines.find(l => Math.abs(l.y - it.y) <= tol);
      if (!line) { line = { y: it.y, items: [], tol }; lines.push(line); }
      line.items.push(it);
    }
    for (const l of lines) {
      l.items.sort((a,b) => a.x - b.x);
      l.text = l.items.map(i => i.str).join(" ").replace(/\s+/g," ").trim();
    }
    lines.sort((a,b) => b.y - a.y);
    return lines;
  }

  function detectServiceColumnsFromHeader(lines) {
    const KEYWORDS = [
      { key:"type", k:["type"] },
      { key:"desc", k:["description","d√©tail","detail"] },
      { key:"pu",   k:["prix","unitaire","pu"] },
      { key:"qty",  k:["quantit√©","quantite","qt√©","qte","quant"] },
      { key:"tva",  k:["tva"] },
      { key:"reduc",k:["r√©duction","reduction"] },
      { key:"total",k:["total"] }
    ];

    let best = null;
    for (const l of lines) {
      const s = (l.text || "").toLowerCase();
      let score = 0;
      for (const kw of KEYWORDS) if (kw.k.some(x => s.includes(x))) score++;
      if (score >= 3) if (!best || score > best.score) best = { line:l, score };
    }

    if (!best) return { found:false, hasReduc:false, xType:0, xDesc:90, xPU:360, xQty:470, xTVA:540, xReduc:585, xTotal:650 };

    const header = best.line;

    function findX(tokens) {
      const it = header.items.find(i => tokens.some(t => i.str.toLowerCase().includes(t)));
      return it ? it.x : null;
    }

    const xDesc = findX(["description","d√©tail","detail"]) ?? 120;
    const xPU = findX(["prix"]) ?? 360;
    const xQty = findX(["quant"]) ?? 470;
    const xTVA = findX(["tva"]) ?? 540;

    const xReducMaybe = findX(["r√©duction","reduction"]);
    const hasReduc = xReducMaybe != null;

    const xTotal = (() => {
      const totals = header.items.filter(i => i.str.toLowerCase().includes("total"));
      if (totals.length) return totals[totals.length - 1].x;
      return 650;
    })();

    const xReduc = hasReduc ? xReducMaybe : Math.min(xTotal - 40, xTVA + 50);

    return { found:true, headerY: header.y, hasReduc, xType:0, xDesc, xPU, xQty, xTVA, xReduc, xTotal };
  }

  function lineToRow(line, cols) {
    const cells = { type:"", desc:"", pu:"", qty:"", tva:"", reduc:"", total:"" };
    for (const it of line.items) {
      const x = it.x;
      const str = it.str;
      if (x < cols.xDesc) cells.type += (cells.type ? " " : "") + str;
      else if (x < cols.xPU) cells.desc += (cells.desc ? " " : "") + str;
      else if (x < cols.xQty) cells.pu += (cells.pu ? " " : "") + str;
      else if (x < cols.xTVA) cells.qty += (cells.qty ? " " : "") + str;
      else if (cols.hasReduc && x < cols.xReduc) cells.tva += (cells.tva ? " " : "") + str;
      else if (cols.hasReduc && x < cols.xTotal) cells.reduc += (cells.reduc ? " " : "") + str;
      else if (!cols.hasReduc && x < cols.xTotal) cells.tva += (cells.tva ? " " : "") + str;
      else cells.total += (cells.total ? " " : "") + str;
    }
    for (const k of Object.keys(cells)) cells[k] = cells[k].replace(/\s+/g," ").trim();
    return cells;
  }

  function fixRowMoneyColumns(row) {
    if ((!row.total || row.total.trim() === "") && row.tva) {
      const m = row.tva.match(/([0-9][0-9\s]*[,\.]\d{2})\s*‚Ç¨?/);
      if (m) {
        const money = m[1].trim() + " ‚Ç¨";
        row.total = money;
        row.tva = row.tva.replace(m[0], "").replace(/\s+/g, " ").trim();
      }
    }
    if (row.tva) {
      const mp = row.tva.match(/(\d{1,3}\s*%)/);
      row.tva = mp ? mp[1] : row.tva;
    }
    return row;
  }

  function recoverDescFromRaw(raw, row) {
    let s = raw || "";
    s = s.replace(/^Service\s*/i, "").trim();
    const removeList = [row.pu, row.qty, row.tva, row.reduc, row.total].filter(Boolean);
    for (const part of removeList) {
      const esc = part.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      s = s.replace(new RegExp(esc, "g"), " ").trim();
    }
    s = s.replace(/\s+/g, " ").trim();
    return s;
  }

  function postFixEmptyDescriptions(services) {
    for (let i = 1; i < services.length; i++) {
      const cur = services[i];
      const prev = services[i - 1];
      const curNoDesc = (!cur.desc || cur.desc.trim().length < 3);
      const curHasMoney = (cur.pu || cur.total);
      if (!curNoDesc || !curHasMoney) continue;

      const prevDesc = prev.desc || "";
      const dateMatches = prevDesc.match(/\b\d{2}\/\d{2}\/\d{4}\b/g);
      if (dateMatches && dateMatches.length >= 2) {
        const second = dateMatches[1];
        const idx = prevDesc.indexOf(second);
        if (idx > 0) {
          prev.desc = prevDesc.slice(0, idx).trim();
          cur.desc = prevDesc.slice(idx).trim();
        }
      }
    }
    return services;
  }

  function extractPdfTableFromTextContent(textContent) {
    const items = textContent.items.map(it => ({
      str: (it.str || "").trim(),
      x: it.transform[4],
      y: it.transform[5],
      h: Math.abs(it.transform[3]) || it.height || 0
    })).filter(it => it.str.length);

    const lines = groupItemsIntoLines(items, 3.2);
    const cols = detectServiceColumnsFromHeader(lines);

    let tableStartIndex = 0;
    if (cols.found) {
      tableStartIndex = lines.findIndex(l => l.y === cols.headerY);
      if (tableStartIndex < 0) tableStartIndex = 0;
    }

    const region = lines.slice(tableStartIndex + 1);
    const stopRe = /(total\s*ht|total\s*ttc|page\s+\d+|ribs?|iban|bic|si[e√®]ge\s+social|conditions)/i;

    const tableLines = [];
    for (const l of region) {
      if (stopRe.test(l.text)) break;
      tableLines.push(l);
    }

    const services = [];
    const debours = [];
    const hasMoney = (s) => /[0-9]\s*[0-9\s]*[,\.]\d{2}/.test(s) || (/‚Ç¨/.test(s) && /\d/.test(s));
    const hasPercent = (s) => /\b\d{1,3}\s*%/.test(s);

    let lastService = null;

    for (const l of tableLines) {
      const raw = l.text || "";
      if (!raw) continue;
      if (/d√©bours/i.test(raw)) { debours.push(raw); lastService = null; continue; }

      const row = lineToRow(l, cols);
      fixRowMoneyColumns(row);

      const looksLikeContinuation =
        !row.type && row.desc && !hasMoney(row.pu) && !hasMoney(row.total) && !hasPercent(row.tva) && !hasPercent(row.reduc);

      if (looksLikeContinuation && lastService) {
        lastService.desc = (lastService.desc + " " + row.desc).replace(/\s+/g," ").trim();
        continue;
      }

      const isService =
        /service/i.test(row.type) ||
        (row.desc && (hasMoney(row.total) || hasMoney(row.pu)) && (row.qty || hasPercent(row.tva)));

      if (isService) {
        if ((!row.desc || row.desc.length < 3) && raw) {
          const fallback = recoverDescFromRaw(raw, row);
          if (fallback && /[A-Za-z√Ä-√ø]/.test(fallback)) row.desc = fallback;
        }
        services.push(row);
        lastService = row;
      }
    }

    postFixEmptyDescriptions(services);

    return {
      services,
      debours,
      cols,
      debug: {
        headerFound: cols.found,
        hasReduc: cols.hasReduc,
        headerY: cols.headerY || null,
        totalLines: lines.length,
        tableLines: tableLines.length,
        servicesDetected: services.length
      }
    };
  }

  // ------------------------------------------------------------
  // ‚úÖ V2.4 ‚Äì TRI UI helpers
  // ------------------------------------------------------------
  function triDefault() {
    return {
      names: ["Destination 1", "Destination 2", "Destination 3"],
      buckets: [[], [], []],
      prices: { a:null, b:null, c:null }
    };
  }

  function safeParseFloat(v) {
    if (v == null) return null;
    const s = String(v).replace(",", ".").replace(/[^0-9.]/g,"").trim();
    if (!s) return null;
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  }

  function renderTriUI(serviceIndex, lineObj) {
    const tri = (lineObj && lineObj.tri) ? lineObj.tri : triDefault();

    const nameA = tri.names?.[0] || "Destination 1";
    const nameB = tri.names?.[1] || "Destination 2";
    const nameC = tri.names?.[2] || "Destination 3";

    const priceA = tri.prices?.a != null ? tri.prices.a : "";
    const priceB = tri.prices?.b != null ? tri.prices.b : "";
    const priceC = tri.prices?.c != null ? tri.prices.c : "";

    return `
      <div class="triWrap" data-tri-wrap="${serviceIndex}">
        <div class="triTitle">üß≠ Tri 3 destinations (glisse les sous-trajets)</div>

        <div class="triCols">
          ${renderTriCol(serviceIndex, 0, nameA, tri.buckets?.[0] || [])}
          ${renderTriCol(serviceIndex, 1, nameB, tri.buckets?.[1] || [])}
          ${renderTriCol(serviceIndex, 2, nameC, tri.buckets?.[2] || [])}
        </div>

        <div class="triFooter">
          <div class="triPrices">
            <div class="muted small">Prix :</div>
            <input placeholder="Prix A" data-tri-price="a" data-idx="${serviceIndex}" value="${escapeHtml(priceA)}">
            <input placeholder="Prix B" data-tri-price="b" data-idx="${serviceIndex}" value="${escapeHtml(priceB)}">
            <input placeholder="Prix C" data-tri-price="c" data-idx="${serviceIndex}" value="${escapeHtml(priceC)}">
            <span class="triNote" id="triSum-${serviceIndex}"></span>
          </div>

          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btnSmall" data-action="tri-copy" data-idx="${serviceIndex}">üìã Copier tri</button>
            <button class="btnSmall" data-action="tri-save" data-idx="${serviceIndex}">üíæ Sauvegarder</button>
            <button class="btnSmall" data-action="tri-reset" data-idx="${serviceIndex}">üßπ Reset</button>
          </div>
        </div>

        <div class="muted small" style="margin-top:6px;">
          üí° Le tri est sauvegard√© dans <span class="mono">factures.donnees_brutes.lines[].tri</span>. Aucun sch√©ma DB √† modifier.
        </div>
      </div>
    `;
  }

  function renderTriCol(serviceIndex, bucketIndex, name, items) {
    const listHtml = (items || []).map((it, k) => renderTriItem(serviceIndex, bucketIndex, it, k)).join("");
    return `
      <div class="triCol" data-tri-col="${bucketIndex}" data-idx="${serviceIndex}">
        <div class="triHead">
          <input class="triName" data-tri-name="${bucketIndex}" data-idx="${serviceIndex}" value="${escapeHtml(name)}">
        </div>
        <div class="triDrop" data-tri-drop="${bucketIndex}" data-idx="${serviceIndex}">
          ${listHtml || `<div class="muted small">D√©pose ici‚Ä¶</div>`}
        </div>
      </div>
    `;
  }

  function renderTriItem(serviceIndex, bucketIndex, it, k) {
    const payload = encodeURIComponent(JSON.stringify(it));
    return `
      <div class="triItem" draggable="true"
           data-tri-item="1"
           data-idx="${serviceIndex}"
           data-bucket="${bucketIndex}"
           data-payload="${payload}">
        <div class="left">
          <div class="h">${escapeHtml(it.heure || "")}</div>
          <div class="t">${escapeHtml(it.texte || "")}</div>
        </div>
        <div style="display:flex; gap:6px; align-items:center;">
          <div class="p">${it.pax != null ? escapeHtml(String(it.pax))+" pax" : ""}</div>
          <button class="rm" data-action="tri-remove" data-idx="${serviceIndex}" data-bucket="${bucketIndex}" data-k="${k}">‚úñ</button>
        </div>
      </div>
    `;
  }

  function computeTriSum(serviceIndex) {
    const wrap = document.querySelector(`[data-tri-wrap="${serviceIndex}"]`);
    if (!wrap) return;
    const a = safeParseFloat(wrap.querySelector(`[data-tri-price="a"][data-idx="${serviceIndex}"]`)?.value);
    const b = safeParseFloat(wrap.querySelector(`[data-tri-price="b"][data-idx="${serviceIndex}"]`)?.value);
    const c = safeParseFloat(wrap.querySelector(`[data-tri-price="c"][data-idx="${serviceIndex}"]`)?.value);
    const sum = (a||0)+(b||0)+(c||0);
    const el = document.getElementById(`triSum-${serviceIndex}`);
    if (el) el.textContent = `Total: ${sum ? sum.toFixed(2) : "0.00"} ‚Ç¨`;
  }

  function getTriStateFromDOM(serviceIndex) {
    const wrap = document.querySelector(`[data-tri-wrap="${serviceIndex}"]`);
    if (!wrap) return triDefault();

    const names = [0,1,2].map(i => wrap.querySelector(`[data-tri-name="${i}"][data-idx="${serviceIndex}"]`)?.value || `Destination ${i+1}`);

    const prices = {
      a: safeParseFloat(wrap.querySelector(`[data-tri-price="a"][data-idx="${serviceIndex}"]`)?.value),
      b: safeParseFloat(wrap.querySelector(`[data-tri-price="b"][data-idx="${serviceIndex}"]`)?.value),
      c: safeParseFloat(wrap.querySelector(`[data-tri-price="c"][data-idx="${serviceIndex}"]`)?.value),
    };

    const buckets = [0,1,2].map(b => {
      const drop = wrap.querySelector(`[data-tri-drop="${b}"][data-idx="${serviceIndex}"]`);
      if (!drop) return [];
      const nodes = drop.querySelectorAll(`[data-tri-item="1"][data-idx="${serviceIndex}"][data-bucket="${b}"]`);
      const list = [];
      nodes.forEach(n => {
        const payload = n.getAttribute("data-payload");
        if (!payload) return;
        try { list.push(JSON.parse(decodeURIComponent(payload))); } catch {}
      });
      return list;
    });

    return { names, buckets, prices };
  }

  function setTriToLine(serviceIndex, triState) {
    // serviceIndex maps to viewerServiceLines index
    if (!viewerServiceLines[serviceIndex]) return;
    viewerServiceLines[serviceIndex].tri = triState;

    // also update in donnees_brutes.lines (same object reference if we built it from there)
    // no-op if already reference.
  }

  // ------------------------------------------------------------
  // Render services table + subtrips + tri
  // ------------------------------------------------------------
  function renderSubTripsTable(trips) {
    if (!trips || trips.length === 0) {
      return `<div class="muted small">Aucun sous-trajet d√©tect√©.</div>`;
    }
    let html = `<table class="subTable">
      <thead><tr><th>Heure</th><th>Texte</th><th>Pax</th></tr></thead><tbody>`;
    for (const t of trips) {
      const payload = encodeURIComponent(JSON.stringify(t));
      html += `<tr>
        <td class="mono">${escapeHtml(t.heure || "")}</td>
        <td>${escapeHtml(t.texte || "")}</td>
        <td>${t.pax != null ? escapeHtml(String(t.pax)) : ""}</td>
      </tr>`;
      // note: drag uses triItem, not table row; we keep as readable only
    }
    html += `</tbody></table>`;
    return html;
  }

  function renderPdfTableHtmlWithTri(services, debours, hasReduc) {
    const showReduc = !!hasReduc || services.some(r => (r.reduc || "").includes("%"));

    let html = `<table class="tablePdf">
      <thead><tr>
        <th>Type</th><th>Description</th><th>PU HT</th><th>Qt√©</th><th>TVA</th>${showReduc ? "<th>R√©duction</th>" : ""}<th>Total HT</th><th></th>
      </tr></thead><tbody>`;

    services.forEach((r, idx) => {
      const subTrips = extractSubTrips(r.desc || "");
      const canToggle = subTrips.length > 0;
      const lineObj = viewerServiceLines[idx] || null;
      const hasTri = lineObj?.tri && (lineObj.tri.buckets?.some(b=>b?.length) || lineObj.tri.prices);

      html += `<tr>
        <td>${escapeHtml(r.type)}</td>
        <td class="desc">${escapeHtml(r.desc)}</td>
        <td>${escapeHtml(r.pu)}</td>
        <td>${escapeHtml(r.qty)}</td>
        <td>${escapeHtml(r.tva)}</td>
        ${showReduc ? `<td>${escapeHtml(r.reduc || "")}</td>` : ""}
        <td>${escapeHtml(r.total)}</td>
        <td style="white-space:nowrap;">
          <button class="btnSmall" data-action="toggle-sub" data-idx="${idx}" ${canToggle ? "" : "disabled"}>üîΩ Sous-trajets</button>
          <button class="btnSmall" data-action="toggle-tri" data-idx="${idx}" ${canToggle ? "" : "disabled"}>üß≠ Tri</button>
          ${hasTri ? `<div class="muted small">‚úÖ tri</div>` : ``}
        </td>
      </tr>`;

      html += `<tr>
        <td colspan="${showReduc ? 8 : 7}">
          <div class="subTripsWrap" id="subWrap-${idx}">
            <div class="subTripsTitle">üß© Sous-trajets d√©tect√©s</div>
            ${renderSubTripsTable(subTrips)}
            <div style="display:flex; gap:8px; margin-top:10px; flex-wrap:wrap;">
              <button class="btnSmall" data-action="copy-sub" data-idx="${idx}" ${canToggle ? "" : "disabled"}>üìã Copier sous-trajets</button>
              <span class="muted small">Tu peux ensuite les glisser dans le tri 3 destinations.</span>
            </div>

            <div class="subTripsTitle" style="margin-top:12px;">üß≤ Sous-trajets (draggables)</div>
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              ${subTrips.map((t) => {
                const payload = encodeURIComponent(JSON.stringify(t));
                return `
                  <div class="triItem" draggable="true"
                       data-drag-source="sub"
                       data-payload="${payload}">
                    <div class="left">
                      <div class="h">${escapeHtml(t.heure || "")}</div>
                      <div class="t">${escapeHtml(t.texte || "")}</div>
                    </div>
                    <div class="p">${t.pax != null ? escapeHtml(String(t.pax))+" pax" : ""}</div>
                  </div>
                `;
              }).join("")}
            </div>

            <div class="subTripsWrap" id="triWrap-${idx}" style="display:none; margin-top:12px;">
              ${renderTriUI(idx, lineObj)}
            </div>
          </div>
        </td>
      </tr>`;
    });

    if (debours.length > 0) {
      html += `<tr class="rowDebours"><td colspan="${showReduc ? 8 : 7}">D√©bours</td></tr>`;
      for (const d of debours) html += `<tr class="rowDebours"><td colspan="${showReduc ? 8 : 7}">${escapeHtml(d)}</td></tr>`;
    }

    html += `</tbody></table>`;
    return html;
  }

  // ------------------------------------------------------------
  // ‚úÖ Parse lines from table rows (heure auto + sub_trips)
  // ------------------------------------------------------------
  function parseLinesFromTable(tablePages, parserOut) {
    const lines = [];
    let idx = 1;

    const allServices = [];
    const allDeboursRaw = [];

    for (const p of (tablePages || [])) {
      if (p?.services) allServices.push(...p.services);
      if (p?.debours) allDeboursRaw.push(...p.debours);
    }

    for (const r of allServices) {
      const desc = (r.desc || "").trim();
      let dateRaw = null, heure = null, cleanDesc = desc;

      const mDateOnly = desc.match(/^(\d{2}\/\d{2}\/\d{4})\s*:\s*(.*)$/);
      if (mDateOnly) {
        dateRaw = mDateOnly[1];
        cleanDesc = (mDateOnly[2] || "").trim();
      }

      const mDH = desc.match(/(\d{2}\/\d{2}\/\d{4})\s*:\s*([0-9]{1,2}h[0-9]{0,2})\s*(.*)/);
      if (mDH) {
        dateRaw = mDH[1];
        heure = mDH[2];
        cleanDesc = (mDH[3] || "").trim() || cleanDesc;
      }

      if (!heure) {
        const mh = cleanDesc.match(/\b(\d{1,2}h\d{2})\b/);
        if (mh) heure = mh[1];
      }

      const dateIso = dateRaw ? parseFrenchDateAny(dateRaw) : null;
      const { source_lieu, destination_lieu } = splitSourceDest(cleanDesc);

      const pu = normalizeNumber(r.pu);
      const pu2 = (typeof pu === "number") ? Math.round(pu * 100) / 100 : pu;
      const qty = parseInt((r.qty || "1").replace(/\D/g,""), 10) || 1;
      const tva = parsePercent(r.tva) || null;
      const reduc = parsePercent(r.reduc) || null;
      const total = normalizeNumber(r.total);

      const sub_trips = extractSubTrips(cleanDesc);

      const obj = {
        type: "service",
        ligne_numero: idx++,
        date_service_raw: dateRaw,
        date_service: dateIso,
        heure_service: heure,
        description_service: cleanDesc,
        source_lieu,
        destination_lieu,
        prix_unitaire_ht: pu2,
        quantite: qty,
        tva,
        reduction_percent: reduc,
        prix_total_ht: total,
        confidence: "high",
        source_text: JSON.stringify(r),
        sub_trips,
        tri: null
      };
      lines.push(obj);

      if (parserOut?.matches) {
        parserOut.matches.push({ label:"service_desc", value: cleanDesc, raw: cleanDesc });
        if (r.total) parserOut.matches.push({ label:"service_total_raw", value: r.total, raw: r.total });
        if (r.pu) parserOut.matches.push({ label:"service_pu_raw", value: r.pu, raw: r.pu });
      }
    }

    for (const raw of allDeboursRaw) {
      const mAmt = raw.match(/([0-9\s.,]+)\s*‚Ç¨\s*$/);
      const amountRaw = mAmt ? mAmt[1].trim() : null;
      const amount = amountRaw ? normalizeNumber(amountRaw) : null;
      const desc = amountRaw ? raw.replace(mAmt[0], "").replace(/\s+/g," ").trim() : raw.trim();

      lines.push({
        type: "debours",
        ligne_numero: idx++,
        description_service: desc,
        prix_total_ht: amount,
        confidence: "high",
        source_text: raw
      });

      if (parserOut?.matches) parserOut.matches.push({ label:"debours_desc", value: desc, raw: raw });
    }

    return lines;
  }

  // ------------------------------------------------------------
  // Render file list
  // ------------------------------------------------------------
  function render() {
    selectedCount.textContent = String(state.files.length);
    const anyBusy = state.files.some(f => ["uploading","extracting"].includes(f.status));
    startUploadBtn.disabled = state.files.length === 0 || anyBusy;
    clearBtn.disabled = state.files.length === 0 || anyBusy;

    filesTbody.innerHTML = "";
    if (state.files.length === 0) {
      filesTbody.innerHTML = `<tr><td colspan="5" class="muted">Aucun fichier</td></tr>`;
      return;
    }

    for (let i = 0; i < state.files.length; i++) {
      const item = state.files[i];
      const pill = (() => {
        if (item.status === "ready") return `<span class="pill">pr√™t</span>`;
        if (item.status === "uploading") return `<span class="pill">upload‚Ä¶</span>`;
        if (item.status === "extracting") return `<span class="pill">traitement‚Ä¶</span>`;
        if (item.status === "extracted") return `<span class="pill ok">OK</span>`;
        if (item.status === "error") return `<span class="pill err">erreur</span>`;
        return `<span class="pill">${item.status}</span>`;
      })();

      filesTbody.insertAdjacentHTML("beforeend", `
        <tr>
          <td>${escapeHtml(item.file.name)}${item.error ? `<div class="muted" style="color:#b00020;">${escapeHtml(item.error)}</div>` : ""}</td>
          <td>${formatBytes(item.file.size)}</td>
          <td>${pill}</td>
          <td>${item.factureId ? `<span class="mono">${item.factureId}</span>` : `<span class="muted">‚Äî</span>`}</td>
          <td>
            <div class="row-actions">
              <button class="btn" data-action="remove" data-index="${i}" ${item.status==="uploading" ? "disabled":""}>Retirer</button>
              <button class="btn" data-action="view" data-index="${i}" ${item.status!=="extracted" ? "disabled":""}>üëÅ Voir</button>
            </div>
          </td>
        </tr>
      `);
    }
  }

  filesTbody.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-action]");
    if (!btn) return;
    const idx = Number(btn.getAttribute("data-index"));
    const action = btn.getAttribute("data-action");
    if (Number.isNaN(idx) || idx < 0 || idx >= state.files.length) return;

    try {
      if (action === "remove") { state.files.splice(idx, 1); render(); return; }
      if (action === "view") { await openViewer(idx); return; }
    } catch (err) {
      console.error(err);
      setMsg("err", "Erreur bouton: " + (err?.message || err));
    }
  });

  // ------------------------------------------------------------
  // File input + drop
  // ------------------------------------------------------------
  function addFiles(fileList) {
    const incoming = Array.from(fileList);
    for (const file of incoming) {
      if (state.files.length >= MAX_FILES) break;
      if (!isPdf(file)) { state.files.push({ file, status:"error", error:"PDF uniquement" }); continue; }
      if (file.size > MAX_SIZE) { state.files.push({ file, status:"error", error:"Max 10MB" }); continue; }
      state.files.push({ file, status:"ready", error:null, factureId:null, uploadPath:null });
    }
    render();
  }

  fileInput.addEventListener("change", (e) => addFiles(e.target.files));
  dropZone.addEventListener("dragover", (e) => { e.preventDefault(); dropZone.classList.add("drag"); });
  dropZone.addEventListener("dragleave", () => dropZone.classList.remove("drag"));
  dropZone.addEventListener("drop", (e) => {
    e.preventDefault();
    dropZone.classList.remove("drag");
    if (e.dataTransfer?.files) addFiles(e.dataTransfer.files);
  });
  clearBtn.onclick = () => { state.files = []; render(); };

  // ------------------------------------------------------------
  // Supabase init
  // ------------------------------------------------------------
  async function waitForSupabaseClient() {
    for (let i = 0; i < 60; i++) {
      if (window.SupabaseClient) return window.SupabaseClient;
      await new Promise(r => setTimeout(r, 100));
    }
    throw new Error("SupabaseClient non initialis√© (timeout)");
  }

  async function ensureLoggedIn() {
    const { data: { user } } = await sb.auth.getUser();
    if (!user) throw new Error("Non connect√©");
    return user;
  }

  // ------------------------------------------------------------
  // ‚úÖ TABLE/VIEWER events: toggle sub, toggle tri, copy sub, tri drag/drop, tri save
  // ------------------------------------------------------------
  let dragPayload = null;

  tableContent.addEventListener("dragstart", (e) => {
    const item = e.target.closest(".triItem[draggable='true']");
    if (!item) return;
    const payload = item.getAttribute("data-payload");
    if (!payload) return;
    dragPayload = payload;
    e.dataTransfer.setData("text/plain", payload);
  });

  tableContent.addEventListener("dragend", () => {
    dragPayload = null;
  });

  tableContent.addEventListener("dragover", (e) => {
    const drop = e.target.closest("[data-tri-drop]");
    if (!drop) return;
    e.preventDefault();
    drop.classList.add("dragOver");
  });

  tableContent.addEventListener("dragleave", (e) => {
    const drop = e.target.closest("[data-tri-drop]");
    if (!drop) return;
    drop.classList.remove("dragOver");
  });

  tableContent.addEventListener("drop", (e) => {
    const drop = e.target.closest("[data-tri-drop]");
    if (!drop) return;
    e.preventDefault();
    drop.classList.remove("dragOver");

    const serviceIndex = Number(drop.getAttribute("data-idx"));
    const bucketIndex = Number(drop.getAttribute("data-tri-drop"));
    if (Number.isNaN(serviceIndex) || Number.isNaN(bucketIndex)) return;

    const payload = e.dataTransfer.getData("text/plain") || dragPayload;
    if (!payload) return;

    let obj = null;
    try { obj = JSON.parse(decodeURIComponent(payload)); } catch { return; }

    // insert into DOM list as triItem
    const wrap = document.querySelector(`[data-tri-wrap="${serviceIndex}"]`);
    if (!wrap) return;

    // remove placeholder text if exists
    const placeholder = drop.querySelector(".muted");
    if (placeholder) placeholder.remove();

    // add new element
    const list = drop.querySelectorAll(".triItem").length;
    drop.insertAdjacentHTML("beforeend", renderTriItem(serviceIndex, bucketIndex, obj, list));
  });

  tableContent.addEventListener("input", (e) => {
    const t = e.target;
    if (t.matches("[data-tri-price]")) {
      const idx = Number(t.getAttribute("data-idx"));
      computeTriSum(idx);
    }
  });

  tableContent.addEventListener("click", async (e) => {
    const btn = e.target.closest("button[data-action]");
    if (!btn) return;

    const action = btn.getAttribute("data-action");
    const idx = Number(btn.getAttribute("data-idx"));
    if (Number.isNaN(idx)) return;

    if (action === "toggle-sub") {
      const wrap = document.getElementById(`subWrap-${idx}`);
      if (wrap) wrap.classList.toggle("open");
      return;
    }

    if (action === "toggle-tri") {
      const tri = document.getElementById(`triWrap-${idx}`);
      if (tri) tri.style.display = (tri.style.display === "none" ? "block" : "none");
      computeTriSum(idx);
      return;
    }

    if (action === "copy-sub") {
      const sub = document.getElementById(`subWrap-${idx}`);
      if (!sub) return;
      const chips = sub.querySelectorAll(".triItem[data-drag-source='sub']");
      const lines = ["Heure\tTexte\tPax"];
      chips.forEach(c => {
        try {
          const obj = JSON.parse(decodeURIComponent(c.getAttribute("data-payload")));
          lines.push(`${obj.heure||""}\t${obj.texte||""}\t${obj.pax!=null?obj.pax:""}`);
        } catch {}
      });
      await navigator.clipboard.writeText(lines.join("\n"));
      btn.textContent = "‚úÖ Copi√©";
      setTimeout(() => btn.textContent = "üìã Copier sous-trajets", 900);
      return;
    }

    if (action === "tri-remove") {
      const bucket = Number(btn.getAttribute("data-bucket"));
      const k = Number(btn.getAttribute("data-k"));
      const wrap = document.querySelector(`[data-tri-wrap="${idx}"]`);
      if (!wrap) return;
      const drop = wrap.querySelector(`[data-tri-drop="${bucket}"][data-idx="${idx}"]`);
      if (!drop) return;
      const items = drop.querySelectorAll(`.triItem[data-idx="${idx}"][data-bucket="${bucket}"]`);
      if (items[k]) items[k].remove();
      if (drop.querySelectorAll(".triItem").length === 0) drop.innerHTML = `<div class="muted small">D√©pose ici‚Ä¶</div>`;
      return;
    }

    if (action === "tri-reset") {
      const wrap = document.querySelector(`[data-tri-wrap="${idx}"]`);
      if (!wrap) return;
      // reset names
      [0,1,2].forEach(i => {
        const inp = wrap.querySelector(`[data-tri-name="${i}"][data-idx="${idx}"]`);
        if (inp) inp.value = `Destination ${i+1}`;
      });
      // reset prices
      ["a","b","c"].forEach(k => {
        const inp = wrap.querySelector(`[data-tri-price="${k}"][data-idx="${idx}"]`);
        if (inp) inp.value = "";
      });
      // reset drops
      [0,1,2].forEach(b => {
        const d = wrap.querySelector(`[data-tri-drop="${b}"][data-idx="${idx}"]`);
        if (d) d.innerHTML = `<div class="muted small">D√©pose ici‚Ä¶</div>`;
      });
      computeTriSum(idx);
      // reset memory
      setTriToLine(idx, triDefault());
      return;
    }

    if (action === "tri-copy") {
      const triState = getTriStateFromDOM(idx);
      const lines = [];
      lines.push(`Destination\tHeure\tTexte\tPax`);
      triState.buckets.forEach((bucket, bi) => {
        const destName = triState.names[bi] || `Destination ${bi+1}`;
        (bucket||[]).forEach(it => {
          lines.push(`${destName}\t${it.heure||""}\t${it.texte||""}\t${it.pax!=null?it.pax:""}`);
        });
      });
      // prices
      lines.push("");
      lines.push(`Prix A\t${triState.prices.a!=null?triState.prices.a:""}`);
      lines.push(`Prix B\t${triState.prices.b!=null?triState.prices.b:""}`);
      lines.push(`Prix C\t${triState.prices.c!=null?triState.prices.c:""}`);

      await navigator.clipboard.writeText(lines.join("\n"));
      btn.textContent = "‚úÖ Copi√©";
      setTimeout(() => btn.textContent = "üìã Copier tri", 900);
      return;
    }

    if (action === "tri-save") {
      if (!viewerFactureId || !viewerDonneesBrutes) return setMsg("err", "Viewer sans contexte facture.");

      const triState = getTriStateFromDOM(idx);
      setTriToLine(idx, triState);

      // Put tri into donnees_brutes.lines (service lines only)
      // viewerServiceLines is subset; we update the original donnees_brutes.lines by matching ligne_numero
      const allLines = viewerDonneesBrutes.lines || [];
      const target = viewerServiceLines[idx];
      if (!target) return setMsg("err", "Impossible de retrouver la ligne structur√©e.");

      const ln = target.ligne_numero;
      const real = allLines.find(l => l.type === "service" && l.ligne_numero === ln);
      if (real) real.tri = triState;

      try {
        await ensureLoggedIn();
        const { error } = await sb
          .from("factures")
          .update({ donnees_brutes: viewerDonneesBrutes })
          .eq("id", viewerFactureId);

        if (error) throw error;

        btn.textContent = "‚úÖ Sauv√©";
        setTimeout(() => btn.textContent = "üíæ Sauvegarder", 1200);
        setMsg("ok", "‚úÖ Tri sauvegard√© dans donnees_brutes.");
      } catch (err) {
        console.error(err);
        setMsg("err", "Erreur sauvegarde tri: " + (err?.message || err));
      }
      return;
    }
  });

  // ------------------------------------------------------------
  // Viewer
  // ------------------------------------------------------------
  async function openViewer(idx) {
    const item = state.files[idx];
    if (!item?.factureId) return;

    const { data, error } = await sb
      .from("factures")
      .select("id,fichier_nom,statut,texte_ocr,created_at,donnees_brutes,numero_facture,date_facture,total_ht,total_tva,total_ttc,client_nom")
      .eq("id", item.factureId)
      .single();
    if (error) return setMsg("err", "Erreur lecture: " + error.message);

    viewerFactureId = data.id;
    viewerDonneesBrutes = data.donnees_brutes || {};
    viewerServiceLines = (viewerDonneesBrutes.lines || []).filter(l => l.type === "service");

    textMeta.innerHTML = `
      <div><strong>Facture ID :</strong> <span class="mono">${escapeHtml(data.id)}</span></div>
      <div><strong>Fichier :</strong> ${escapeHtml(data.fichier_nom || "‚Äî")}</div>
      <div><strong>Statut :</strong> <span class="mono">${escapeHtml(data.statut || "‚Äî")}</span></div>
      <div><strong>Cr√©√© le :</strong> ${escapeHtml(data.created_at || "‚Äî")}</div>
    `;

    renderHighlightsBox(data);
    setTab("text");
    textModal.classList.add("open");

    const tablePages = data?.donnees_brutes?.table || [];
    const servicesAll = [];
    const deboursAll = [];
    let hasReduc = false;

    for (const p of tablePages) {
      if (p?.services) servicesAll.push(...p.services);
      if (p?.debours) deboursAll.push(...p.debours);
      if (p?.debug?.hasReduc) hasReduc = true;
    }

    tableContent.innerHTML = (servicesAll.length || deboursAll.length)
      ? renderPdfTableHtmlWithTri(servicesAll, deboursAll, hasReduc)
      : `<div class="muted">Aucun tableau d√©tect√©. V√©rifie donnees_brutes.table_debug.</div>`;

    // init sums
    for (let i = 0; i < servicesAll.length; i++) computeTriSum(i);

    textContent.innerHTML = "<i>Chargement‚Ä¶</i>";
    const rawText = (data.texte_ocr || "").trim();
    const highlights = buildHighlightsFromDB(data);
    requestAnimationFrame(() => {
      textContent.innerHTML = highlightText(rawText || "‚ö†Ô∏è Aucun texte.", highlights);
    });
  }

  // ------------------------------------------------------------
  // Upload + Extract (identique logique, mais version parser v24)
  // ------------------------------------------------------------
  async function uploadAndProcessOne(item) {
    item.status = "uploading"; item.error = null; render();
    try {
      await ensureLoggedIn();

      const year = new Date().getFullYear();
      const ts = Date.now();
      const filename = `${ts}_${sanitizeFilename(item.file.name)}`;
      const path = `${year}/${filename}`;

      const { data: up, error: upErr } = await sb.storage.from("factures").upload(path, item.file, {
        upsert:false, cacheControl:"3600", contentType:"application/pdf"
      });
      if (upErr) throw upErr;
      item.uploadPath = up.path;

      const { data: inserted, error: dbErr } = await sb
        .from("factures")
        .insert({ fichier_url: up.path, fichier_nom: item.file.name, statut:"pending", format_facture:"moderne" })
        .select("id")
        .single();
      if (dbErr) throw dbErr;
      item.factureId = inserted.id;

      item.status = "extracting"; render();
      await extractParseSaveAndInsert(item);

      item.status = "extracted"; render();
    } catch (err) {
      item.status = "error";
      item.error = err?.message || String(err);
      render();
      if (item.factureId) await sb.from("factures").update({ statut:"error", error_message:item.error }).eq("id", item.factureId);
    }
  }

  async function extractParseSaveAndInsert(item) {
    const { data: signed, error: signErr } = await sb.storage.from("factures").createSignedUrl(item.uploadPath, 60*10);
    if (signErr) throw signErr;

    const res = await fetch(signed.signedUrl);
    if (!res.ok) throw new Error("T√©l√©chargement PDF impossible");
    const arrayBuffer = await res.arrayBuffer();

    const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;

    let fullText = "";
    const tablePages = [];

    for (let p=1; p<=pdf.numPages; p++) {
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();

      fullText += `\n\n=== PAGE ${p} ===\n` + content.items.map(it => it.str).join(" ");
      const table = extractPdfTableFromTextContent(content);
      tablePages.push({ page: p, ...table });
    }

    fullText = fullText.trim();
    if (fullText.length < 30) throw new Error("Texte extrait vide/trop court (PDF scan ?)");

    const parsed = parseInvoiceText(fullText);
    parsed.table = tablePages;
    parsed.lines = parseLinesFromTable(tablePages, parsed);

    parsed.table_debug = tablePages.map(tp => ({
      page: tp.page,
      headerFound: tp.debug?.headerFound,
      hasReduc: tp.debug?.hasReduc,
      servicesDetected: tp.debug?.servicesDetected,
      tableLines: tp.debug?.tableLines
    }));

    const payload = { texte_ocr: fullText, statut:"extracted", donnees_brutes: parsed };

    if (parsed?.fields?.numero_facture) payload.numero_facture = parsed.fields.numero_facture;
    if (parsed?.fields?.date_facture) payload.date_facture = parsed.fields.date_facture;
    if (parsed?.fields?.client_nom) payload.client_nom = parsed.fields.client_nom;
    if (typeof parsed?.fields?.total_ht === "number") payload.total_ht = parsed.fields.total_ht;
    if (typeof parsed?.fields?.total_tva === "number") payload.total_tva = parsed.fields.total_tva;
    if (typeof parsed?.fields?.total_ttc === "number") payload.total_ttc = parsed.fields.total_ttc;

    const { error: updErr } = await sb.from("factures").update(payload).eq("id", item.factureId);
    if (updErr) throw updErr;

    // Keep inserts into existing tables
    const services = parsed.lines.filter(l => l.type === "service");
    const debours = parsed.lines.filter(l => l.type === "debours");

    if (services.length > 0) {
      const rowsLF = services.map(l => ({
        facture_id: item.factureId,
        ligne_numero: l.ligne_numero,
        date_service: l.date_service,
        heure_service: l.heure_service,
        source_lieu: l.source_lieu,
        destination_lieu: l.destination_lieu,
        description_service: l.description_service,
        trajet_brut: l.description_service,
        prix_unitaire_ht: l.prix_unitaire_ht,
        quantite: l.quantite,
        tva: l.tva,
        reduction_percent: l.reduction_percent,
        prix_total_ht: l.prix_total_ht,
        flags: { confidence:l.confidence, source_text:l.source_text, sub_trips: l.sub_trips || [] }
      }));

      const { error: lfErr } = await sb.from("lignes_factures").insert(rowsLF);
      if (lfErr) throw lfErr;

      const year = parsed?.fields?.date_facture ? parseInt(parsed.fields.date_facture.slice(0,4),10) : new Date().getFullYear();
      const rowsSAS = services.map(l => ({
        facture_id: item.factureId,
        annee: year,
        date_service: l.date_service,
        heure_service: l.heure_service,
        source_lieu: l.source_lieu,
        destination_lieu: l.destination_lieu,
        source_text: l.source_text,
        prix_unitaire_ht: l.prix_unitaire_ht,
        quantite: l.quantite,
        tva: l.tva,
        reduction_percent: l.reduction_percent,
        total_ht: l.prix_total_ht,
        flags: { confidence:l.confidence, sub_trips: l.sub_trips || [] },
        status: "READY"
      }));

      const { error: sasErr } = await sb.from("import_factures_rows").insert(rowsSAS);
      if (sasErr) throw sasErr;
    }

    if (debours.length > 0) {
      const rowsDeb = debours.map(l => ({
        facture_id: item.factureId,
        ligne_numero: l.ligne_numero,
        description_service: "DEBOURS: " + l.description_service,
        trajet_brut: l.description_service,
        prix_total_ht: l.prix_total_ht,
        flags: { type:"debours", source_text:l.source_text }
      }));
      await sb.from("lignes_factures").insert(rowsDeb);
    }
  }

  // ------------------------------------------------------------
  // Init app
  // ------------------------------------------------------------
  (async () => {
    try {
      sb = await waitForSupabaseClient();
      if (window.pdfjsLib?.GlobalWorkerOptions) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc =
          "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      }

      async function refreshAuthStatus() {
        const { data: { user } } = await sb.auth.getUser();
        if (user) {
          authStatus.textContent = "Connect√©: " + (user.email || user.id);
          logoutBtn.disabled = false;
          emailInput.style.display = "none";
          passInput.style.display = "none";
          loginBtn.style.display = "none";
          setMsg("", "");
        } else {
          authStatus.textContent = "Non connect√©";
          logoutBtn.disabled = true;
          emailInput.style.display = "";
          passInput.style.display = "";
          loginBtn.style.display = "";
          setMsg("warn", "Connecte-toi pour uploader (bucket priv√©).");
        }
        render();
      }

      loginBtn.onclick = async () => {
        const email = (emailInput.value || "").trim();
        const password = passInput.value || "";
        if (!email || !password) return setMsg("warn", "Email et mot de passe requis.");
        setMsg("warn", "Connexion‚Ä¶");
        const { error } = await sb.auth.signInWithPassword({ email, password });
        if (error) return setMsg("err", "Erreur login: " + error.message);
        passInput.value = "";
        await refreshAuthStatus();
        setMsg("ok", "‚úÖ Connect√©.");
      };

      logoutBtn.onclick = async () => { await sb.auth.signOut(); await refreshAuthStatus(); };
      sb.auth.onAuthStateChange(() => refreshAuthStatus());
      await refreshAuthStatus();

      startUploadBtn.onclick = async () => {
        try { await ensureLoggedIn(); } catch { return setMsg("warn", "Connecte-toi d‚Äôabord pour uploader."); }
        setMsg("warn", "Traitement en cours‚Ä¶");
        const toProcess = state.files.filter(f => f.status === "ready");
        for (const item of toProcess) await uploadAndProcessOne(item);

        const okCount = state.files.filter(f => f.status === "extracted").length;
        const errCount = state.files.filter(f => f.status === "error").length;
        if (errCount === 0) setMsg("ok", `‚úÖ Termin√© : ${okCount} facture(s) trait√©e(s).`);
        else setMsg("err", `‚ö†Ô∏è Termin√© : ${okCount} OK, ${errCount} erreurs.`);
      };

      render();
    } catch (e) {
      console.error(e);
      setMsg("err", "Supabase non initialis√©. Recharge la page.");
    }
  })();
</script>
</body>
</html>
