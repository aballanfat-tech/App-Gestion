<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Import Factures</title>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <style>
    :root{
      --bg:#fafafa;
      --card:#ffffff;
      --muted:#6b7280;
      --border:#e5e7eb;
      --border2:#d1d5db;
      --ok:#10b981;
      --warn:#f59e0b;
      --err:#ef4444;
      --hl:#ffe58f;
      --btn:#ffffff;
      --btn2:#111827;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:#111827;
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding:14px 18px;
      background:#fff; border-bottom:1px solid var(--border);
      position:sticky; top:0; z-index:100;
      flex-wrap:wrap;
    }
    main{ max-width: 1100px; margin: 18px auto; padding: 0 14px; }

    .row{display:flex; gap:10px; flex-wrap:wrap;}
    .btn{
      cursor:pointer;
      border:1px solid var(--border2);
      background:var(--btn);
      padding:10px 12px;
      border-radius:12px;
      font-weight:600;
      user-select:none;
    }
    .btn:hover{ border-color:#9ca3af; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }
    .btn.primary{ background:#111827; color:#fff; border-color:#111827; }
    .btn.ghost{ background:#fff; color:#111827; }
    .btn.small{ padding:7px 10px; font-size:12px; border-radius:10px; font-weight:600; }

    .field{
      border:1px solid var(--border2);
      background:#fff;
      padding:10px 12px;
      border-radius:12px;
      outline:none;
      min-width: 180px;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }
    .muted{ color:var(--muted); font-size:13px; }
    .small{ font-size:12px; }
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px;
      margin-bottom:14px;
    }
    .notice{
      background:#fff7d6;
      border:1px solid #f1d88a;
      border-radius:14px;
      padding:10px 12px;
      margin-bottom:14px;
    }
    .msg{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--border);
      background:#fff;
      margin-bottom:12px;
      font-weight:600;
    }
    .msg.ok{ border-color:#9ad39a; background:#f2fff2; }
    .msg.warn{ border-color:#f1d88a; background:#fff7d6; }
    .msg.err{ border-color:#ffb3b3; background:#fff2f2; }

    /* Dropzone */
    .drop{
      border:2px dashed #bdbdbd;
      border-radius:16px;
      padding:22px;
      text-align:center;
      background:#fcfcfc;
      transition: .15s;
    }
    .drop.drag{
      border-color:#111827;
      background:#fff;
      transform: scale(1.01);
    }

    table{ width:100%; border-collapse: collapse; }
    th, td{ border-bottom:1px solid #eee; padding:10px 8px; text-align:left; vertical-align:top; }
    th{ font-size:12px; text-transform:uppercase; letter-spacing:.04em; color:#6b7280; background:#fafafa; }
    .pill{
      display:inline-block;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid var(--border2);
      font-size:12px;
      font-weight:700;
    }
    .pill.ok{ border-color:#9ad39a; color:#047857; background:#ecfdf5; }
    .pill.err{ border-color:#ffb3b3; color:#b91c1c; background:#fff1f2; }
    .pill.wait{ border-color:#f1d88a; color:#92400e; background:#fff7d6; }

    /* Modal */
    #modal{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center; justify-content:center;
      padding:18px;
      z-index:9999;
    }
    #modal.open{ display:flex; }
    .modalBox{
      width:min(1200px, 98vw);
      max-height:92vh;
      background:#fff;
      border-radius:16px;
      border:1px solid var(--border);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      border-bottom:1px solid #eee;
      gap:8px;
      flex-wrap:wrap;
    }
    .modalBody{
      padding:12px 14px;
      overflow:auto;
    }
    .tabs{
      display:flex; gap:8px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .tab{
      cursor:pointer;
      border:1px solid var(--border2);
      background:#fff;
      padding:8px 10px;
      border-radius:12px;
      font-weight:800;
      font-size:12px;
    }
    .tab.active{ background:#111827; color:#fff; border-color:#111827; }

    mark.hl{ background:var(--hl); padding:0 2px; border-radius:4px; }

    /* Editor */
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      background:#fafafa;
      border:1px solid #eee;
      padding:12px;
      border-radius:14px;
      margin:8px 0 12px;
    }
    .grid2 .full{ grid-column: 1 / -1; }
    .label{ font-size:12px; color:#6b7280; margin-bottom:5px; font-weight:800; }
    .grid2 input{
      width:100%;
      border:1px solid var(--border2);
      padding:9px 10px;
      border-radius:12px;
      background:#fff;
      font-size:13px;
      outline:none;
    }

    .editTable{
      width:100%;
      border-collapse: collapse;
      border:1px solid #eee;
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }
    .editTable th{ background:#f7f7f7; }
    .editTable td{ border-bottom:1px solid #eee; }
    .editTable input, .editTable select{
      width:100%;
      border:1px solid var(--border2);
      padding:8px 9px;
      border-radius:12px;
      background:#fff;
      font-size:12px;
      outline:none;
    }
    .actions{ display:flex; gap:8px; flex-wrap:wrap; }

    /* Tri destinations */
    .triBox{
      background:#fafafa;
      border:1px solid #eee;
      padding:12px;
      border-radius:14px;
      margin-top:12px;
    }
    .triHead{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .triNames{ display:flex; gap:8px; flex-wrap:wrap; }
    .triNames input{ width:170px; }
    .triRow{
      display:grid;
      grid-template-columns: 1fr 120px 120px 120px 110px;
      gap:8px;
      margin-top:10px;
      align-items:center;
    }
    .triRow input{
      border:1px solid var(--border2);
      padding:8px 9px;
      border-radius:12px;
      background:#fff;
      font-size:12px;
      outline:none;
    }
    .triRow .btn.small{ justify-self:start; }
    .triMeta{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .triMeta .pill{ background:#fff; }
  </style>
</head>

<body>
<header>
  <div class="row" style="align-items:center;">
    <button class="btn" id="backBtn">‚¨ÖÔ∏è Retour</button>
    <div>
      <div style="font-weight:900;">üì§ Import Factures ‚Äî V2.6.5</div>
      <div class="muted small">Table detector V2.2 + fallback OCR + √©dition + autosave + tri modifiable</div>
    </div>
  </div>

  <div class="row" style="align-items:center;">
    <span class="muted" id="authStatus">Connexion‚Ä¶</span>
    <input class="field" id="email" type="email" placeholder="Email">
    <input class="field" id="pass" type="password" placeholder="Mot de passe">
    <button class="btn primary" id="loginBtn">Se connecter</button>
    <button class="btn" id="logoutBtn" disabled>Se d√©connecter</button>
  </div>
</header>

<main>
  <div id="msg" class="msg warn" style="display:none;"></div>

  <div class="notice">
    ‚úÖ Si le PDF ne permet pas de d√©tecter l‚Äôen-t√™te du tableau (X/Y) ‚Üí <strong>fallback OCR</strong> (reconstruction depuis le texte).<br>
    ‚úÖ Tout est <strong>√©ditable</strong> avant int√©gration : client, dates, totaux, lignes, tri destinations (ajout/suppression).
  </div>

  <div class="card">
    <div class="drop" id="drop">
      <div style="font-size:18px; font-weight:900;">Glisse-d√©pose tes PDFs ici</div>
      <div class="muted">PDF uniquement ‚Ä¢ max 10 MB/fichier ‚Ä¢ max 20 fichiers</div>
      <div style="margin-top:12px;">
        <input type="file" id="fileInput" accept="application/pdf" multiple>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <button class="btn primary" id="startBtn" disabled>üöÄ Uploader & Extraire</button>
      <button class="btn" id="clearBtn" disabled>üßπ Vider la liste</button>
      <button class="btn" id="reloadBtn">üîÑ Recharger la liste</button>
    </div>

    <div class="muted small" style="margin-top:10px;">
      üíæ La liste est sauvegard√©e (localStorage). Les factures d√©j√† import√©es restent visibles.
    </div>
  </div>

  <div class="card">
    <div class="row" style="align-items:center; justify-content:space-between;">
      <div style="font-weight:900;">üìÑ Factures</div>
      <div class="muted" id="count">0</div>
    </div>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>Fichier</th>
            <th>Taille</th>
            <th>Statut</th>
            <th>ID</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="tbody">
          <tr><td colspan="5" class="muted">Aucun fichier</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</main>

<!-- MODAL -->
<div id="modal">
  <div class="modalBox">
    <div class="modalHead">
      <div>
        <div style="font-weight:900;">üßæ Viewer facture</div>
        <div class="muted small" id="meta"></div>
      </div>
      <div class="row">
        <button class="btn" id="reparseBtn">üîÅ Re-Parser</button>
        <button class="btn" id="saveBtn">üíæ Sauvegarder</button>
        <button class="btn" id="closeBtn">‚úñ Fermer</button>
      </div>
    </div>

    <div class="modalBody">
      <div class="row" style="align-items:center; justify-content:space-between;">
        <div class="row" id="tags" style="gap:8px;"></div>
        <div class="muted small" id="autosaveInfo"></div>
      </div>

      <div class="tabs">
        <button class="tab active" data-tab="edit">üüß Edition</button>
        <button class="tab" data-tab="table">üü© Tableau</button>
        <button class="tab" data-tab="text">üü¶ Texte</button>
        <button class="tab" data-tab="debug">üß™ Debug</button>
      </div>

      <div id="tab-edit">
        <div style="font-weight:900; margin:8px 0;">üß© En-t√™te facture (√©ditable)</div>
        <div class="grid2" id="editHeader"></div>

        <div style="font-weight:900; margin:12px 0 6px;">üöå Lignes (services) (√©ditables)</div>
        <div class="actions" style="margin-bottom:8px;">
          <button class="btn small" id="addLineBtn">‚ûï Ajouter une ligne</button>
        </div>
        <div id="editLines"></div>

        <div style="font-weight:900; margin:14px 0 6px;">üß≠ Tri destinations (A / B / C) ‚Äî modifiable</div>
        <div class="triBox">
          <div class="triHead">
            <div class="triNames">
              <div>
                <div class="label">Nom A</div>
                <input id="triNameA" placeholder="Ex: Excursions">
              </div>
              <div>
                <div class="label">Nom B</div>
                <input id="triNameB" placeholder="Ex: Navettes">
              </div>
              <div>
                <div class="label">Nom C</div>
                <input id="triNameC" placeholder="Ex: D√©bours">
              </div>
            </div>
            <div class="row">
              <button class="btn small" id="addTriRowBtn">‚ûï Ajouter une ligne</button>
              <button class="btn small" id="applyTriBtn">üß† Auto-sugg√©rer</button>
            </div>
          </div>

          <div class="triRow" style="font-weight:900; color:#6b7280;">
            <div>Libell√© / Description</div>
            <div>Cat√©gorie</div>
            <div>Prix HT</div>
            <div>Qt√©</div>
            <div>Action</div>
          </div>
          <div id="triRows"></div>

          <div class="triMeta">
            <span class="pill" id="sumA">A: 0‚Ç¨</span>
            <span class="pill" id="sumB">B: 0‚Ç¨</span>
            <span class="pill" id="sumC">C: 0‚Ç¨</span>
            <span class="pill" id="sumAll">Total: 0‚Ç¨</span>
          </div>

          <div class="muted small" style="margin-top:10px;">
            ‚úÖ Tu peux modifier, ajouter, supprimer des lignes avant int√©gration vers la grille.
          </div>
        </div>
      </div>

      <div id="tab-table" style="display:none;">
        <div class="muted small" style="margin:8px 0;">
          Tableau reconstruit depuis X/Y PDF. Si vide ‚Üí fallback OCR (texte).
        </div>
        <div id="tableHtml"></div>
      </div>

      <div id="tab-text" style="display:none;">
        <div class="muted small" style="margin:8px 0;">
          Les √©l√©ments reconnus sont surlign√©s.
        </div>
        <div id="textHtml" style="white-space:pre-wrap; word-break:break-word; background:#fafafa; border:1px solid #eee; border-radius:14px; padding:12px; font-size:13px; line-height:1.35;"></div>
      </div>

      <div id="tab-debug" style="display:none;">
        <div class="muted small" style="margin:8px 0;">donnees_brutes (JSON)</div>
        <pre id="debugJson" class="mono" style="background:#0b1020; color:#e5e7eb; border-radius:14px; padding:12px; overflow:auto; max-height:55vh;"></pre>
      </div>
    </div>
  </div>
</div>

<!-- Supabase -->
<script src="./supabase-core.js"></script>
<script src="./supabase-services.js"></script>

<script>
/* ============================
   IMPORT FACTURES ‚Äî V2.6.5
   Table detector v2.2 + fallback OCR + editor + autosave + tri editable
============================ */
(() => {
  const APP_VERSION = "v265";
  const LS_KEY = "import_factures_state_" + APP_VERSION;
  const MAX_FILES = 20;
  const MAX_SIZE = 10 * 1024 * 1024;

  // DOM
  const backBtn = document.getElementById("backBtn");
  const msgBox = document.getElementById("msg");

  const drop = document.getElementById("drop");
  const fileInput = document.getElementById("fileInput");
  const startBtn = document.getElementById("startBtn");
  const clearBtn = document.getElementById("clearBtn");
  const reloadBtn = document.getElementById("reloadBtn");
  const tbody = document.getElementById("tbody");
  const count = document.getElementById("count");

  const authStatus = document.getElementById("authStatus");
  const email = document.getElementById("email");
  const pass = document.getElementById("pass");
  const loginBtn = document.getElementById("loginBtn");
  const logoutBtn = document.getElementById("logoutBtn");

  const modal = document.getElementById("modal");
  const closeBtn = document.getElementById("closeBtn");
  const reparseBtn = document.getElementById("reparseBtn");
  const saveBtn = document.getElementById("saveBtn");

  const meta = document.getElementById("meta");
  const tags = document.getElementById("tags");
  const autosaveInfo = document.getElementById("autosaveInfo");

  const tabButtons = Array.from(document.querySelectorAll(".tab"));
  const tabEdit = document.getElementById("tab-edit");
  const tabTable = document.getElementById("tab-table");
  const tabText = document.getElementById("tab-text");
  const tabDebug = document.getElementById("tab-debug");

  const editHeader = document.getElementById("editHeader");
  const editLines = document.getElementById("editLines");

  const addLineBtn = document.getElementById("addLineBtn");

  const triNameA = document.getElementById("triNameA");
  const triNameB = document.getElementById("triNameB");
  const triNameC = document.getElementById("triNameC");
  const triRows = document.getElementById("triRows");
  const addTriRowBtn = document.getElementById("addTriRowBtn");
  const applyTriBtn = document.getElementById("applyTriBtn");

  const sumA = document.getElementById("sumA");
  const sumB = document.getElementById("sumB");
  const sumC = document.getElementById("sumC");
  const sumAll = document.getElementById("sumAll");

  const tableHtml = document.getElementById("tableHtml");
  const textHtml = document.getElementById("textHtml");
  const debugJson = document.getElementById("debugJson");

  // State
  const state = { files: [] };
  let sb = null;
  let sessionOk = false;
  let keepAliveTimer = null;

  // Viewer state
  let viewerFactureId = null;
  let viewerRawText = "";
  let viewerData = null; // donnees_brutes
  let viewerRowCache = []; // editable lines
  let triCache = []; // editable tri rows

  // Autosave
  let autosaveTimer = null;
  let autosaveDirty = false;
  let lastAutosaveAt = 0;

  // ----------------------------
  // Utilities
  // ----------------------------
  function setMsg(type, text){
    msgBox.className = "msg " + (type || "warn");
    msgBox.textContent = text || "";
    msgBox.style.display = text ? "block" : "none";
  }
  function escapeHtml(s){
    return (s||"").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }
  function escapeRegExp(str){
    return String(str).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function formatBytes(bytes){
    const b = Number(bytes)||0;
    if(b<1024) return b+" B";
    const kb=b/1024;
    if(kb<1024) return kb.toFixed(1)+" KB";
    return (kb/1024).toFixed(1)+" MB";
  }
  function isPdf(file){
    return file && (file.type==="application/pdf" || file.name.toLowerCase().endsWith(".pdf"));
  }
  function sanitizeFilename(name){
    return name.replace(/[^a-zA-Z0-9.\-_]/g, "_").replace(/_{2,}/g, "_");
  }
  function normalizeSpaces(s){
    return (s||"").replace(/\s+/g, " ").trim();
  }
  function normalizeNumber(str){
    if(!str) return null;
    const n = String(str).replace(/\s/g, "").replace(",", ".");
    const val = parseFloat(n.replace(/[^0-9.]/g, ""));
    return Number.isFinite(val) ? val : null;
  }
  function parseFrenchDateAny(dateStr){
    if(!dateStr) return null;
    const s = String(dateStr).trim();
    const mNum = s.match(/(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})/);
    if(mNum){
      let d=parseInt(mNum[1],10), mo=parseInt(mNum[2],10), y=parseInt(mNum[3],10);
      if(y<100) y+=2000;
      return `${y.toString().padStart(4,"0")}-${String(mo).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
    }
    const months = {
      "janvier":1,"f√©vrier":2,"fevrier":2,"mars":3,"avril":4,"mai":5,"juin":6,
      "juillet":7,"ao√ªt":8,"aout":8,"septembre":9,"octobre":10,"novembre":11,
      "d√©cembre":12,"decembre":12
    };
    const mTxt = s.toLowerCase().match(/(\d{1,2})\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+(\d{4})/);
    if(mTxt){
      const d=parseInt(mTxt[1],10), mo=months[mTxt[2]], y=parseInt(mTxt[3],10);
      if(!mo) return null;
      return `${y}-${String(mo).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
    }
    return null;
  }
  function cleanClientName(raw){
    if(!raw) return null;
    let s = normalizeSpaces(raw);
    // stop markers frequently found after recipient block
    const stops = [" Conditions", " D√©tail", " Detail", " RIB", " IBAN", " BIC", " Titulaire", " Total", " TVA"];
    for(const st of stops){
      const idx = s.indexOf(st);
      if(idx>2){ s = s.slice(0, idx).trim(); break; }
    }
    // cut zipcode/city tail
    s = s.replace(/\b\d{5}\b[\s\S]*$/g, "").trim();
    // cut country tail
    s = s.replace(/\b(France|Belgique|Suisse|Luxembourg)\b[\s\S]*$/i, "").trim();
    // cut trailing punctuation
    s = s.replace(/[;,:-]+$/g, "").trim();

    // sometimes client comes duplicated: "Association OVAL Association OVAL"
    // remove immediate duplication
    const parts = s.split(" ");
    if(parts.length>=2){
      const half = Math.floor(parts.length/2);
      const left = parts.slice(0, half).join(" ");
      const right = parts.slice(half).join(" ");
      if(left && right && left.toLowerCase() === right.toLowerCase()){
        s = left;
      }
    }
    return s || null;
  }
  function moneyToEuro(str){
    const n = normalizeNumber(str);
    return (n==null) ? "" : (Math.round(n*100)/100).toFixed(2) + " ‚Ç¨";
  }

  // ----------------------------
  // localStorage list persistence
  // ----------------------------
  function saveList(){
    try{
      const compact = state.files
        .filter(x => x.kind==="saved" || (x.kind==="local" && x.factureId))
        .map(x => ({
          kind:"saved",
          fileName: x.kind==="local" ? x.file.name : x.fileName,
          size: x.kind==="local" ? x.file.size : x.size,
          status: x.status || "extracted",
          factureId: x.factureId || null,
          createdAt: x.createdAt || new Date().toISOString()
        }));
      localStorage.setItem(LS_KEY, JSON.stringify({ savedAt: Date.now(), files: compact }));
    }catch(e){}
  }
  function restoreList(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return false;
      const data = JSON.parse(raw);
      if(!data?.files?.length) return false;
      state.files = data.files.map(f => ({
        kind:"saved",
        fileName: f.fileName || "Facture.pdf",
        size: f.size || 0,
        status: f.status || "extracted",
        factureId: f.factureId || null,
        createdAt: f.createdAt || null,
        error: null
      }));
      return true;
    }catch(e){ return false; }
  }

  // ----------------------------
  // Rendering list
  // ----------------------------
  function renderList(){
    count.textContent = String(state.files.length);

    const anyBusy = state.files.some(f => ["uploading","extracting"].includes(f.status));
    startBtn.disabled = !sessionOk || anyBusy || state.files.filter(f => f.kind==="local" && f.status==="ready").length===0;
    clearBtn.disabled = anyBusy;

    tbody.innerHTML = "";
    if(state.files.length===0){
      tbody.innerHTML = `<tr><td colspan="5" class="muted">Aucun fichier</td></tr>`;
      return;
    }

    for(let i=0;i<state.files.length;i++){
      const it = state.files[i];
      const fileName = it.kind==="local" ? it.file.name : it.fileName;
      const size = it.kind==="local" ? it.file.size : it.size;

      let pill = `<span class="pill">${escapeHtml(it.status || "‚Äî")}</span>`;
      if(it.status==="extracted") pill = `<span class="pill ok">OK</span>`;
      if(it.status==="error") pill = `<span class="pill err">Erreur</span>`;
      if(it.status==="uploading" || it.status==="extracting") pill = `<span class="pill wait">${escapeHtml(it.status)}</span>`;

      tbody.insertAdjacentHTML("beforeend", `
        <tr>
          <td>
            <div style="font-weight:900;">${escapeHtml(fileName)}</div>
            ${it.error ? `<div class="muted" style="color:#b91c1c; font-weight:800;">${escapeHtml(it.error)}</div>` : ""}
          </td>
          <td>${formatBytes(size)}</td>
          <td>${pill}</td>
          <td>${it.factureId ? `<span class="mono">${escapeHtml(it.factureId)}</span>` : `<span class="muted">‚Äî</span>`}</td>
          <td>
            <div class="actions">
              <button class="btn small" data-action="remove" data-i="${i}" ${anyBusy?"disabled":""}>Retirer</button>
              <button class="btn small" data-action="view" data-i="${i}" ${(!it.factureId || it.status!=="extracted")?"disabled":""}>üëÅ Voir</button>
            </div>
          </td>
        </tr>
      `);
    }

    saveList();
  }

  tbody.addEventListener("click", async (e) => {
    const b = e.target.closest("button[data-action]");
    if(!b) return;
    const idx = Number(b.getAttribute("data-i"));
    const action = b.getAttribute("data-action");
    if(Number.isNaN(idx) || idx<0 || idx>=state.files.length) return;

    if(action==="remove"){
      state.files.splice(idx, 1);
      renderList();
    }
    if(action==="view"){
      await openViewerByIndex(idx);
    }
  });

  // ----------------------------
  // Dropzone
  // ----------------------------
  function addFiles(fileList){
    const incoming = Array.from(fileList || []);
    for(const file of incoming){
      if(state.files.length >= MAX_FILES) break;
      if(!isPdf(file)){
        state.files.push({ kind:"local", file, status:"error", error:"PDF uniquement" });
        continue;
      }
      if(file.size > MAX_SIZE){
        state.files.push({ kind:"local", file, status:"error", error:"Max 10MB" });
        continue;
      }
      state.files.push({ kind:"local", file, status:"ready", error:null, factureId:null, uploadPath:null });
    }
    renderList();
  }

  fileInput.addEventListener("change", (e) => addFiles(e.target.files));
  drop.addEventListener("dragover", (e) => { e.preventDefault(); drop.classList.add("drag"); });
  drop.addEventListener("dragleave", () => drop.classList.remove("drag"));
  drop.addEventListener("drop", (e) => {
    e.preventDefault();
    drop.classList.remove("drag");
    if(e.dataTransfer?.files) addFiles(e.dataTransfer.files);
  });

  clearBtn.addEventListener("click", () => {
    // keep saved only
    state.files = state.files.filter(x => x.kind==="saved");
    renderList();
  });
  reloadBtn.addEventListener("click", () => {
    state.files = [];
    restoreList();
    renderList();
    setMsg("ok", "‚úÖ Liste recharg√©e depuis localStorage");
    setTimeout(()=>setMsg("", ""), 900);
  });

  backBtn.addEventListener("click", () => {
    window.location.href = "index.html";
  });

  // ----------------------------
  // Tabs
  // ----------------------------
  function setTab(name){
    tabButtons.forEach(b => b.classList.toggle("active", b.dataset.tab===name));
    tabEdit.style.display = (name==="edit") ? "block" : "none";
    tabTable.style.display = (name==="table") ? "block" : "none";
    tabText.style.display = (name==="text") ? "block" : "none";
    tabDebug.style.display = (name==="debug") ? "block" : "none";
  }
  tabButtons.forEach(b => b.addEventListener("click", () => setTab(b.dataset.tab)));

  // ----------------------------
  // Modal
  // ----------------------------
  function openModal(){
    modal.classList.add("open");
  }
  function closeModal(){
    modal.classList.remove("open");
    viewerFactureId = null;
    viewerRawText = "";
    viewerData = null;
    viewerRowCache = [];
    triCache = [];
    clearTimeout(autosaveTimer);
    autosaveTimer = null;
    autosaveDirty = false;
  }
  closeBtn.addEventListener("click", closeModal);
  modal.addEventListener("click", (e) => { if(e.target === modal) closeModal(); });

  // ----------------------------
  // Supabase init
  // ----------------------------
  async function waitForSupabaseClient(){
    for(let i=0;i<70;i++){
      if(window.SupabaseClient) return window.SupabaseClient;
      await new Promise(r => setTimeout(r, 100));
    }
    throw new Error("SupabaseClient non initialis√© (timeout)");
  }

  async function refreshSession(){
    try{
      const { data:{ user } } = await sb.auth.getUser();
      sessionOk = !!user;
      if(sessionOk){
        authStatus.textContent = "Connect√©: " + (user.email || user.id);
        logoutBtn.disabled = false;
        email.style.display="none";
        pass.style.display="none";
        loginBtn.style.display="none";
      } else {
        authStatus.textContent = "Non connect√©";
        logoutBtn.disabled = true;
        email.style.display="";
        pass.style.display="";
        loginBtn.style.display="";
      }
      renderList();
    }catch(e){
      sessionOk = false;
      authStatus.textContent = "Non connect√©";
      logoutBtn.disabled = true;
      renderList();
    }
  }

  function startKeepAlive(){
    clearInterval(keepAliveTimer);
    keepAliveTimer = setInterval(async () => {
      await refreshSession();
    }, 120000);
  }

  loginBtn.addEventListener("click", async () => {
    const em = (email.value||"").trim();
    const pw = pass.value || "";
    if(!em || !pw){
      setMsg("warn", "Email + mot de passe requis.");
      return;
    }
    setMsg("warn", "Connexion‚Ä¶");
    const { error } = await sb.auth.signInWithPassword({ email: em, password: pw });
    if(error){
      setMsg("err", "Erreur login: " + error.message);
      return;
    }
    pass.value = "";
    await refreshSession();
    setMsg("ok", "‚úÖ Connect√©");
    setTimeout(()=>setMsg("", ""), 900);
  });

  logoutBtn.addEventListener("click", async () => {
    await sb.auth.signOut();
    await refreshSession();
    setMsg("warn", "D√©connect√©");
    setTimeout(()=>setMsg("", ""), 900);
  });

  // ----------------------------
  // Extraction PDF text via PDF.js
  // ----------------------------
  async function extractPdfTextFromArrayBuffer(arrayBuffer){
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    let fullText = "";
    for(let p=1; p<=pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      const text = content.items.map(it => it.str).join(" ");
      fullText += `\n\n=== PAGE ${p} ===\n${text}`;
    }
    return fullText.trim();
  }

  // ----------------------------
  // Parser fields robust (v2.6.5)
  // ----------------------------
  function parseFieldsRobust(fullText){
    const out = { fields:{}, matches:[], version:"parser_table_v265", parsed_at: new Date().toISOString() };
    const t = normalizeSpaces(fullText || "");

    // Numero facture
    const mFact = t.match(/\bFacture\s+["']?\s*([A-Z]{2,6}-\d{3,4}-\d{2,}|FACT-\d{4}-\d{2,})\s*["']?/i)
                || t.match(/\b(FACT-\d{4}-\d{2,})\b/i);
    if(mFact){
      const val = (mFact[1] || mFact[0]).replace(/Facture/i, "").replace(/["']/g, "").trim();
      out.fields.numero_facture = val;
      out.matches.push({ raw: mFact[0], label:"numero_facture", value: val });
    }

    // Date facture
    const mDateTxt = t.match(/\b(\d{1,2}\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+\d{4})\b/i);
    const mDateNum = t.match(/\b(\d{1,2}[\/\-.]\d{1,2}[\/\-.]\d{2,4})\b/);
    const rawDate = mDateTxt ? mDateTxt[1] : (mDateNum ? mDateNum[1] : null);
    if(rawDate){
      const iso = parseFrenchDateAny(rawDate);
      if(iso){
        out.fields.date_facture = iso;
        out.matches.push({ raw: rawDate, label:"date_facture", value: rawDate });
      }
    }

    // Client destinataire (bloc apr√®s "Destinataire")
    const mDest = t.match(/Destinataire\s+([\s\S]+?)(Conditions|D√©tail|Detail|RIB|IBAN|BIC|Total\s*HT|Total\s*TTC)/i);
    if(mDest){
      const rawBlock = normalizeSpaces(mDest[1] || "");
      const clean = cleanClientName(rawBlock);
      if(clean){
        out.fields.client_nom = clean;
        out.matches.push({ raw: rawBlock, label:"client_nom", value: clean });
      }
    } else {
      // fallback: sometimes "Soci√©t√© : Nom : ..." for recipient
      const mNom = t.match(/Nom\s*:\s*([A-Z√â√à√ä√Ä√Ç√é√è√î√õ√ô√á0-9][\s\S]{2,120}?)(Adresse|Pays|RIB|IBAN|BIC|Conditions|D√©tail|Total)/i);
      if(mNom){
        const clean = cleanClientName(mNom[1]);
        if(clean){
          out.fields.client_nom = clean;
          out.matches.push({ raw: mNom[0], label:"client_nom", value: clean });
        }
      }
    }

    // Totaux
    const mTotals = t.match(/Total\s*HT[\s:]+([0-9\s.,]+)\s*‚Ç¨[\s\S]{0,80}?TVA[\s\S]{0,50}?([0-9\s.,]+)\s*‚Ç¨[\s\S]{0,80}?Total\s*TTC[\s:]+([0-9\s.,]+)\s*‚Ç¨/i);
    if(mTotals){
      out.fields.total_ht = normalizeNumber(mTotals[1]);
      out.fields.total_tva = normalizeNumber(mTotals[2]);
      out.fields.total_ttc = normalizeNumber(mTotals[3]);
      out.matches.push({ raw: mTotals[0], label:"total_ht", value: mTotals[1] });
      out.matches.push({ raw: mTotals[0], label:"total_tva", value: mTotals[2] });
      out.matches.push({ raw: mTotals[0], label:"total_ttc", value: mTotals[3] });
    } else {
      // fallback: separate lines
      const mHT = t.match(/Total\s*HT\s*[:\s]\s*([0-9\s.,]+)\s*‚Ç¨/i);
      const mTVA = t.match(/\bTVA\b[\s\S]{0,10}?([0-9\s.,]+)\s*‚Ç¨/i);
      const mTTC = t.match(/Total\s*TTC\s*[:\s]\s*([0-9\s.,]+)\s*‚Ç¨/i);
      if(mHT){ out.fields.total_ht = normalizeNumber(mHT[1]); out.matches.push({ raw: mHT[0], label:"total_ht", value:mHT[1] }); }
      if(mTVA){ out.fields.total_tva = normalizeNumber(mTVA[1]); out.matches.push({ raw: mTVA[0], label:"total_tva", value:mTVA[1] }); }
      if(mTTC){ out.fields.total_ttc = normalizeNumber(mTTC[1]); out.matches.push({ raw: mTTC[0], label:"total_ttc", value:mTTC[1] }); }
    }

    return out;
  }

  // ----------------------------
  // Table detector v2.2 (X/Y) ‚Äî Simplified but robust
  // It tries:
  // 1) detect header line "Type Description Prix unitaire HT Quantit√© TVA Total HT"
  // 2) compute column X anchors from header tokens
  // 3) group items by Y into rows
  // 4) extract cells by X range
  //
  // If fails -> fallback OCR table reconstruction
  // ----------------------------
  async function extractPdfItemsXY(arrayBuffer){
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    const pages = [];
    for(let p=1; p<=pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const viewport = page.getViewport({ scale: 1.0 });
      const content = await page.getTextContent();
      const items = content.items.map(it => {
        const tx = it.transform; // [a,b,c,d,e,f]
        const x = tx[4];
        const y = tx[5];
        return { str: it.str, x, y, w: it.width || 0, h: it.height || 0 };
      });
      pages.push({ page:p, items, viewport });
    }
    return pages;
  }

  function detectHeaderAndCols(items){
    // find candidate line containing keywords (any order)
    // We build lines by Y buckets
    const lines = groupByLine(items, 2.5);
    let header = null;

    const keywords = ["type","description","prix","unitaire","quantit√©","quantite","tva","total"];
    for(const line of lines){
      const txt = normalizeSpaces(line.text).toLowerCase();
      let score = 0;
      for(const k of keywords) if(txt.includes(k)) score++;
      if(score >= 5){
        header = line;
        break;
      }
    }
    if(!header){
      return { found:false, headerY:null, cols: defaultCols(), headerFound:false };
    }

    // Determine X anchors from tokens within header line
    // We'll approximate:
    // xType: min
    // xDesc: near "Description"
    // xPU: near "Prix unitaire"
    // xQty: near "Quantit√©"
    // xTVA: near "TVA"
    // xTotal: near "Total"
    const tokens = header.tokens.sort((a,b)=>a.x-b.x);
    function findTokenX(word){
      const t = tokens.find(t => normalizeSpaces(t.str).toLowerCase().includes(word));
      return t ? t.x : null;
    }

    let xType = tokens[0]?.x ?? 0;
    let xDesc = findTokenX("description");
    let xPU = findTokenX("prix");
    let xQty = findTokenX("quant");
    let xTVA = findTokenX("tva");
    let xTotal = findTokenX("total");

    // Fallback approximate if missing
    const xs = tokens.map(t=>t.x).sort((a,b)=>a-b);
    const minX = xs[0] || 0;
    const maxX = xs[xs.length-1] || 700;

    if(xDesc==null) xDesc = minX + (maxX-minX)*0.15;
    if(xPU==null) xPU = minX + (maxX-minX)*0.58;
    if(xQty==null) xQty = minX + (maxX-minX)*0.70;
    if(xTVA==null) xTVA = minX + (maxX-minX)*0.78;
    if(xTotal==null) xTotal = minX + (maxX-minX)*0.86;

    // detect optional reduction column by presence of "R√©duction"
    const hasReduc = normalizeSpaces(header.text).toLowerCase().includes("r√©duction") || normalizeSpaces(header.text).toLowerCase().includes("reduction");
    let xReduc = null;
    if(hasReduc){
      xReduc = findTokenX("r√©duc") || findTokenX("reduc") || (minX + (maxX-minX)*0.82);
      // shift total a bit right
      if(xTotal < xReduc) xTotal = xReduc + 40;
    } else {
      xReduc = xTVA + 40;
    }

    return {
      found:true,
      headerFound:true,
      headerY: header.y,
      cols:{
        xType, xDesc, xPU, xQty, xTVA, xReduc, xTotal,
        hasReduc, found:true
      }
    };
  }

  function defaultCols(){
    return {
      xType:0, xDesc:90, xPU:360, xQty:470, xTVA:540, xReduc:585, xTotal:650,
      hasReduc:false, found:false
    };
  }

  function groupByLine(items, yTolerance=2.5){
    const sorted = items.slice().sort((a,b)=> (b.y - a.y) || (a.x - b.x)); // y desc
    const lines = [];
    for(const it of sorted){
      if(!it.str || !it.str.trim()) continue;
      let line = lines.find(l => Math.abs(l.y - it.y) <= yTolerance);
      if(!line){
        line = { y: it.y, tokens: [], text:"" };
        lines.push(line);
      }
      line.tokens.push(it);
    }
    for(const l of lines){
      l.tokens.sort((a,b)=>a.x-b.x);
      l.text = l.tokens.map(t=>t.str).join(" ");
    }
    lines.sort((a,b)=>b.y-a.y);
    return lines;
  }

  function isMoneyToken(s){
    return /[0-9][0-9\s]*[,\.]\d{2}\s*‚Ç¨?/.test(s);
  }
  function isQtyToken(s){
    return /^\s*\d{1,3}\s*$/.test(s);
  }
  function isTvaToken(s){
    return /^\s*\d{1,2}\s*%\s*$/.test(s) || /\bTVA\b/i.test(s);
  }

  function extractTableFromXY(pageItems){
    // detect header + cols
    const head = detectHeaderAndCols(pageItems);
    const cols = head.cols || defaultCols();
    const headerY = head.headerY;

    // group by lines and pick those below header
    const lines = groupByLine(pageItems, 2.5);
    const tableLines = [];
    let inTable = false;

    for(const l of lines){
      if(headerY!=null && l.y <= headerY + 1){ // below header
        inTable = true;
      }
      if(!inTable) continue;

      // stop when totals/footer
      const txt = normalizeSpaces(l.text).toLowerCase();
      if(txt.includes("total ht") && txt.includes("total ttc")) break;
      if(txt.includes("sas au capital") || txt.includes("sarl au capital")) break;
      if(txt.includes("page") && txt.includes("sur")) continue;

      tableLines.push(l);
    }

    // build rows: a row begins with "Service" or "D√©bours" in Type column region
    const rows = [];
    let current = null;

    function flush(){
      if(current){
        rows.push(current);
        current = null;
      }
    }

    for(const l of tableLines){
      const tokens = l.tokens;
      // slice tokens into columns by X thresholds
      const cell = getCellsFromLine(tokens, cols);
      const type = normalizeSpaces(cell.type).toLowerCase();
      const hasType = type.includes("service") || type.includes("debours") || type.includes("d√©bours") || type.includes("frais") || type.includes("prest");
      const hasMoney = isMoneyToken(cell.pu) || isMoneyToken(cell.total);

      if(hasType && hasMoney){
        flush();
        current = { type: cell.type, desc: cell.desc, pu: cell.pu, qty: cell.qty, tva: cell.tva, reduc: cell.reduc, total: cell.total };
      } else {
        // continuation line -> append to desc if current exists
        if(current){
          const extra = normalizeSpaces(l.text);
          if(extra && extra.length>1){
            // remove repeated money tokens from continuation
            const extraClean = extra.replace(/[0-9][0-9\s]*[,\.]\d{2}\s*‚Ç¨?/g, "").replace(/\s+/g, " ").trim();
            if(extraClean) current.desc = normalizeSpaces(current.desc + " " + extraClean);
          }
        }
      }
    }
    flush();

    // basic cleanup
    const services = rows
      .filter(r => normalizeSpaces(r.type).toLowerCase().includes("service") || normalizeSpaces(r.type).toLowerCase().includes("debours") || normalizeSpaces(r.type).toLowerCase().includes("d√©bours"))
      .map(r => ({
        type: normalizeSpaces(r.type) || "Service",
        desc: normalizeSpaces(r.desc),
        pu: normalizeSpaces(r.pu),
        qty: normalizeSpaces(r.qty),
        tva: normalizeSpaces(r.tva),
        reduc: normalizeSpaces(r.reduc),
        total: normalizeSpaces(r.total)
      }))
      .filter(r => r.desc || r.total || r.pu);

    return {
      cols: cols,
      debug: {
        headerFound: head.headerFound,
        headerY: headerY ?? null,
        hasReduc: cols.hasReduc,
        tableLines: tableLines.length,
        servicesDetected: services.length,
        totalLines: lines.length
      },
      services,
      debours: []
    };
  }

  function getCellsFromLine(tokens, cols){
    // allocate tokens to a cell based on x threshold
    const typeTokens=[], descTokens=[], puTokens=[], qtyTokens=[], tvaTokens=[], reducTokens=[], totalTokens=[];
    for(const t of tokens){
      const x = t.x;
      const s = t.str;
      if(x < cols.xDesc) typeTokens.push(s);
      else if(x < cols.xPU) descTokens.push(s);
      else if(x < cols.xQty) puTokens.push(s);
      else if(x < cols.xTVA) qtyTokens.push(s);
      else if(cols.hasReduc && x < cols.xReduc) tvaTokens.push(s);
      else if(cols.hasReduc && x < cols.xTotal) reducTokens.push(s);
      else if(!cols.hasReduc && x < cols.xTotal) tvaTokens.push(s);
      else totalTokens.push(s);
    }
    return {
      type: typeTokens.join(" "),
      desc: descTokens.join(" "),
      pu: puTokens.join(" "),
      qty: qtyTokens.join(" "),
      tva: tvaTokens.join(" "),
      reduc: reducTokens.join(" "),
      total: totalTokens.join(" ")
    };
  }

  // ----------------------------
  // Fallback OCR table reconstruction (Claude-like)
  // Works from text if XY table empty or header missing
  // ----------------------------
  function fallbackTableFromOCRText(fullText){
    const t = normalizeSpaces(fullText || "");
    const services = [];

    // Split by "Service" keyword. If absent, fallback to scan money patterns.
    const chunks = t.split(/\bService\b/i);
    if(chunks.length > 1){
      for(const rawChunk of chunks.slice(1)){
        const c = normalizeSpaces(rawChunk);
        // find money values
        const moneyRe = /([0-9][0-9\s]*[,\.]\d{2})\s*‚Ç¨/g;
        const moneys = Array.from(c.matchAll(moneyRe)).map(m => (m[1]+" ‚Ç¨").replace(/\s+/g, " ").trim());
        if(moneys.length < 2) continue;

        const total = moneys[moneys.length-1];
        const pu = moneys[0];

        const mTVA = c.match(/\b(\d{1,3})\s*%\b/);
        const tva = mTVA ? (mTVA[1]+"%") : "10%";

        // qty heuristic
        let qty = "1";
        const idx = c.indexOf(pu.replace(" ‚Ç¨",""));
        if(idx >= 0){
          const after = c.slice(idx);
          const mQty = after.match(/\b(\d{1,3})\b/);
          if(mQty) qty = mQty[1];
        }

        let desc = c;
        const cut = c.indexOf(pu.replace(" ‚Ç¨",""));
        if(cut>0) desc = c.slice(0, cut).trim();
        desc = normalizeSpaces(desc);

        services.push({ type:"Service", desc, pu, qty, tva, reduc:"", total });
      }
    } else {
      // fallback scan: detect patterns with dates + money
      const lines = (fullText||"").split(/\n/).map(l => l.trim()).filter(Boolean);
      for(const l of lines){
        if(!/[0-9][0-9\s]*[,\.]\d{2}\s*‚Ç¨/.test(l)) continue;
        const mAll = Array.from(l.matchAll(/([0-9][0-9\s]*[,\.]\d{2})\s*‚Ç¨/g)).map(m => (m[1]+" ‚Ç¨").replace(/\s+/g," ").trim());
        if(mAll.length < 2) continue;
        services.push({
          type:"Service",
          desc: normalizeSpaces(l.replace(/([0-9][0-9\s]*[,\.]\d{2})\s*‚Ç¨/g, "").trim()),
          pu: mAll[0],
          qty: "1",
          tva: "10%",
          reduc:"",
          total: mAll[mAll.length-1]
        });
      }
    }

    return {
      cols: defaultCols(),
      debug:{
        headerFound:false,
        headerY:null,
        hasReduc:false,
        tableLines: 0,
        servicesDetected: services.length,
        totalLines: 0,
        fallback:true
      },
      services,
      debours:[]
    };
  }

  // ----------------------------
  // Highlight helpers
  // ----------------------------
  function getHighlightValues(data){
    const set = new Set();
    const matches = data?.matches || [];
    for(const m of matches){
      const v = (m.value || "").toString().trim();
      if(v.length>=3 && v.length<=220) set.add(v);
    }
    const f = data?.fields || {};
    ["numero_facture","date_facture","client_nom"].forEach(k => {
      const v = (f[k]||"").toString().trim();
      if(v.length>=3 && v.length<=220) set.add(v);
    });
    return Array.from(set).sort((a,b)=>b.length-a.length);
  }

  function renderHighlightedText(rawText, values){
    let html = escapeHtml(rawText || "");
    for(const v of values){
      const re = new RegExp(escapeRegExp(escapeHtml(v)), "g");
      html = html.replace(re, `<mark class="hl">${escapeHtml(v)}</mark>`);
    }
    return html;
  }

  function renderTableHtml(data){
    const pages = data?.table || [];
    const rows = [];
    for(const p of pages){
      if(p?.services?.length) rows.push(...p.services);
    }
    if(rows.length===0){
      return `<div class="muted">Aucun tableau d√©tect√© (m√™me fallback). V√©rifie le texte extrait.</div>`;
    }

    const hasReduc = rows.some(r => (r.reduc||"").trim().length>0);

    return `
      <table class="editTable">
        <thead>
          <tr>
            <th>Type</th>
            <th>Description</th>
            <th>PU HT</th>
            <th>Qt√©</th>
            <th>TVA</th>
            ${hasReduc ? "<th>R√©duc</th>" : ""}
            <th>Total HT</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map(r => `
            <tr>
              <td>${escapeHtml(r.type || "Service")}</td>
              <td>${escapeHtml(r.desc || "")}</td>
              <td>${escapeHtml(r.pu || "")}</td>
              <td>${escapeHtml(r.qty || "")}</td>
              <td>${escapeHtml(r.tva || "")}</td>
              ${hasReduc ? `<td>${escapeHtml(r.reduc || "")}</td>` : ""}
              <td>${escapeHtml(r.total || "")}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;
  }

  // ----------------------------
  // Editor render
  // ----------------------------
  function renderViewerHeader(){
    const f = viewerData?.fields || (viewerData.fields = {});
    editHeader.innerHTML = `
      <div>
        <div class="label">Num√©ro facture</div>
        <input data-h="numero_facture" value="${escapeHtml(f.numero_facture || "")}">
      </div>
      <div>
        <div class="label">Date facture (YYYY-MM-DD)</div>
        <input data-h="date_facture" value="${escapeHtml(f.date_facture || "")}">
      </div>
      <div class="full">
        <div class="label">Client (nom seul)</div>
        <input data-h="client_nom" value="${escapeHtml(f.client_nom || "")}">
      </div>
      <div>
        <div class="label">Total HT</div>
        <input data-h="total_ht" value="${escapeHtml(f.total_ht!=null ? String(f.total_ht) : "")}">
      </div>
      <div>
        <div class="label">Total TVA</div>
        <input data-h="total_tva" value="${escapeHtml(f.total_tva!=null ? String(f.total_tva) : "")}">
      </div>
      <div>
        <div class="label">Total TTC</div>
        <input data-h="total_ttc" value="${escapeHtml(f.total_ttc!=null ? String(f.total_ttc) : "")}">
      </div>
    `;
  }

  function normalizeLineRow(r){
    return {
      type: r.type || "Service",
      desc: r.desc || "",
      pu: r.pu || "",
      qty: r.qty || "1",
      tva: r.tva || "10%",
      reduc: r.reduc || "",
      total: r.total || ""
    };
  }

  function loadViewerLinesFromData(){
    // flatten table services into editable cache
    const rows = [];
    const pages = viewerData?.table || [];
    for(const p of pages){
      if(p?.services?.length) rows.push(...p.services);
    }
    viewerRowCache = rows.map(normalizeLineRow);
    if(viewerRowCache.length===0){
      // fallback: create 1 blank line so user can fill
      viewerRowCache = [normalizeLineRow({})];
    }
  }

  function renderViewerLines(){
    const hasReduc = viewerRowCache.some(r => (r.reduc||"").trim().length>0);
    const reducTh = hasReduc ? "<th>R√©duc</th>" : "";

    editLines.innerHTML = `
      <table class="editTable">
        <thead>
          <tr>
            <th>Type</th>
            <th>Description</th>
            <th>PU</th>
            <th>Qt√©</th>
            <th>TVA</th>
            ${reducTh}
            <th>Total</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${viewerRowCache.map((r, idx) => `
            <tr data-line="${idx}">
              <td>
                <select data-k="type">
                  <option ${r.type==="Service"?"selected":""}>Service</option>
                  <option ${r.type.toLowerCase().includes("d√©bours")?"selected":""}>D√©bours</option>
                </select>
              </td>
              <td><input data-k="desc" value="${escapeHtml(r.desc)}"></td>
              <td><input data-k="pu" value="${escapeHtml(r.pu)}"></td>
              <td><input data-k="qty" value="${escapeHtml(r.qty)}"></td>
              <td><input data-k="tva" value="${escapeHtml(r.tva)}"></td>
              ${hasReduc ? `<td><input data-k="reduc" value="${escapeHtml(r.reduc)}"></td>` : ""}
              <td><input data-k="total" value="${escapeHtml(r.total)}"></td>
              <td>
                <div class="actions">
                  <button class="btn small" data-action="dup-line" data-idx="${idx}">Dupliquer</button>
                  <button class="btn small" data-action="del-line" data-idx="${idx}">Supprimer</button>
                </div>
              </td>
            </tr>
          `).join("")}
        </tbody>
      </table>
      <div class="muted small" style="margin-top:8px;">
        ‚úÖ Tu peux modifier chaque cellule. Les changements sont autosave (toutes les 600ms).
      </div>
    `;
  }

  function updateViewerDataTableFromCache(){
    // Build a single page table from cache (simpler)
    viewerData.table = [{
      page: 0,
      cols: defaultCols(),
      debug: { headerFound: true, servicesDetected: viewerRowCache.length, rebuiltFromEditor:true },
      services: viewerRowCache.map(r => ({
        type: r.type || "Service",
        desc: normalizeSpaces(r.desc),
        pu: normalizeSpaces(r.pu),
        qty: normalizeSpaces(r.qty),
        tva: normalizeSpaces(r.tva),
        reduc: normalizeSpaces(r.reduc),
        total: normalizeSpaces(r.total)
      })),
      debours:[]
    }];
  }

  // ----------------------------
  // Tri destinations editor
  // ----------------------------
  function initTriFromLines(){
    // If we already have tri in donnees_brutes, load it
    const tri = viewerData?.tri || null;
    if(tri){
      triNameA.value = tri.nameA || "A";
      triNameB.value = tri.nameB || "B";
      triNameC.value = tri.nameC || "C";
      triCache = (tri.rows || []).map(r => ({
        label: r.label || "",
        cat: r.cat || "A",
        price: r.price || "",
        qty: r.qty || "1"
      }));
    } else {
      // default tri names
      triNameA.value = "Excursions";
      triNameB.value = "Navettes";
      triNameC.value = "D√©bours";
      // seed tri rows from services
      triCache = viewerRowCache.map(r => ({
        label: r.desc || "",
        cat: "A",
        price: r.total || r.pu || "",
        qty: r.qty || "1"
      }));
    }
    renderTri();
    computeTriSums();
  }

  function renderTri(){
    triRows.innerHTML = triCache.map((r, idx) => `
      <div class="triRow" data-tri="${idx}">
        <input data-k="label" value="${escapeHtml(r.label)}" placeholder="Libell√©...">
        <input data-k="cat" value="${escapeHtml(r.cat)}" placeholder="A/B/C">
        <input data-k="price" value="${escapeHtml(r.price)}" placeholder="Prix HT">
        <input data-k="qty" value="${escapeHtml(r.qty)}" placeholder="Qt√©">
        <button class="btn small" data-action="del-tri" data-idx="${idx}">Supprimer</button>
      </div>
    `).join("");
  }

  function computeTriSums(){
    let a=0,b=0,c=0;
    for(const r of triCache){
      const cat = (r.cat||"A").trim().toUpperCase();
      const qty = normalizeNumber(r.qty) ?? parseInt((r.qty||"1").trim(),10) || 1;
      const price = normalizeNumber(r.price) ?? 0;
      const val = price * qty;
      if(cat==="A") a += val;
      else if(cat==="B") b += val;
      else c += val;
    }
    sumA.textContent = `${triNameA.value || "A"}: ${a.toFixed(2)}‚Ç¨`;
    sumB.textContent = `${triNameB.value || "B"}: ${b.toFixed(2)}‚Ç¨`;
    sumC.textContent = `${triNameC.value || "C"}: ${c.toFixed(2)}‚Ç¨`;
    sumAll.textContent = `Total: ${(a+b+c).toFixed(2)}‚Ç¨`;
  }

  function saveTriToViewerData(){
    viewerData.tri = {
      nameA: triNameA.value || "A",
      nameB: triNameB.value || "B",
      nameC: triNameC.value || "C",
      rows: triCache.map(r => ({ label:r.label, cat:r.cat, price:r.price, qty:r.qty }))
    };
  }

  function autoSuggestTri(){
    // Very basic suggestion based on keywords
    const kwC = ["p√©age","peage","parking","repas","h√¥tel","hotel","billet","entr√©e","entree","taxi","avion","train","frais"];
    const kwB = ["navette","transfert","a√©roport","aeroport","gare","retour","arriv√©e","arrivee"];
    for(const r of triCache){
      const s = (r.label||"").toLowerCase();
      if(kwC.some(k => s.includes(k))) r.cat = "C";
      else if(kwB.some(k => s.includes(k))) r.cat = "B";
      else r.cat = "A";
    }
    renderTri();
    computeTriSums();
    autosaveSchedule("tri-suggest");
  }

  // ----------------------------
  // Autosave (robust)
  // ----------------------------
  function autosaveSchedule(reason="change"){
    autosaveDirty = true;
    autosaveInfo.textContent = "‚úçÔ∏è Modifications‚Ä¶";
    clearTimeout(autosaveTimer);
    autosaveTimer = setTimeout(async () => {
      if(!viewerFactureId || !viewerData || !sessionOk) return;
      // merge editor cache into viewerData
      updateViewerDataTableFromCache();
      saveTriToViewerData();

      try{
        const f = viewerData.fields || {};
        const payload = {
          donnees_brutes: viewerData,
          numero_facture: f.numero_facture || null,
          date_facture: f.date_facture || null,
          client_nom: f.client_nom || null,
          total_ht: (typeof f.total_ht==="number") ? f.total_ht : (normalizeNumber(f.total_ht) ?? null),
          total_tva: (typeof f.total_tva==="number") ? f.total_tva : (normalizeNumber(f.total_tva) ?? null),
          total_ttc: (typeof f.total_ttc==="number") ? f.total_ttc : (normalizeNumber(f.total_ttc) ?? null),
          statut: "extracted"
        };
        const { error } = await sb.from("factures").update(payload).eq("id", viewerFactureId);
        if(error) throw error;
        autosaveDirty = false;
        lastAutosaveAt = Date.now();
        autosaveInfo.textContent = "‚úÖ Autosave (" + reason + ")";
        setTimeout(() => {
          if(!autosaveDirty) autosaveInfo.textContent = "Derni√®re sauvegarde: " + new Date(lastAutosaveAt).toLocaleTimeString();
        }, 1000);
        // refresh viewer tabs rendering
        tableHtml.innerHTML = renderTableHtml(viewerData);
        debugJson.textContent = JSON.stringify(viewerData, null, 2);
      } catch(e){
        console.error(e);
        autosaveInfo.textContent = "‚ùå Autosave erreur";
        setMsg("err", "Autosave impossible: " + (e?.message || e));
      }
    }, 600);
  }

  // manual save
  saveBtn.addEventListener("click", () => autosaveSchedule("manual-save"));

  // ----------------------------
  // Viewer editing events (delegated)
  // ----------------------------
  editHeader.addEventListener("input", (e) => {
    const inp = e.target;
    if(!inp.matches("[data-h]")) return;
    const key = inp.getAttribute("data-h");
    const v = inp.value;
    const f = viewerData.fields || (viewerData.fields = {});
    if(key==="total_ht" || key==="total_tva" || key==="total_ttc"){
      f[key] = normalizeNumber(v);
    } else if(key==="date_facture"){
      // accept direct iso or parse if french
      const iso = parseFrenchDateAny(v) || v.trim();
      f[key] = iso;
    } else {
      f[key] = v.trim();
    }
    refreshTags();
    autosaveSchedule("header");
  });

  editLines.addEventListener("input", (e) => {
    const inp = e.target;
    const rowEl = inp.closest("tr[data-line]");
    if(!rowEl) return;
    const idx = Number(rowEl.getAttribute("data-line"));
    if(Number.isNaN(idx) || !viewerRowCache[idx]) return;
    const k = inp.getAttribute("data-k");
    if(!k) return;
    viewerRowCache[idx][k] = inp.value;
    autosaveSchedule("lines");
  });

  editLines.addEventListener("change", (e) => {
    const sel = e.target;
    const rowEl = sel.closest("tr[data-line]");
    if(!rowEl) return;
    const idx = Number(rowEl.getAttribute("data-line"));
    if(Number.isNaN(idx) || !viewerRowCache[idx]) return;
    const k = sel.getAttribute("data-k");
    if(!k) return;
    viewerRowCache[idx][k] = sel.value;
    autosaveSchedule("lines");
  });

  editLines.addEventListener("click", (e) => {
    const b = e.target.closest("button[data-action]");
    if(!b) return;
    const action = b.getAttribute("data-action");
    const idx = Number(b.getAttribute("data-idx"));
    if(Number.isNaN(idx)) return;

    if(action==="del-line"){
      viewerRowCache.splice(idx, 1);
      if(viewerRowCache.length===0) viewerRowCache.push(normalizeLineRow({}));
      renderViewerLines();
      initTriFromLines(); // rebuild tri from new list
      autosaveSchedule("del-line");
    }
    if(action==="dup-line"){
      const copy = JSON.parse(JSON.stringify(viewerRowCache[idx] || normalizeLineRow({})));
      viewerRowCache.splice(idx+1, 0, copy);
      renderViewerLines();
      initTriFromLines();
      autosaveSchedule("dup-line");
    }
  });

  addLineBtn.addEventListener("click", () => {
    viewerRowCache.push(normalizeLineRow({}));
    renderViewerLines();
    initTriFromLines();
    autosaveSchedule("add-line");
  });

  // tri editing
  triRows.addEventListener("input", (e) => {
    const inp = e.target;
    const rowEl = inp.closest(".triRow[data-tri]");
    if(!rowEl) return;
    const idx = Number(rowEl.getAttribute("data-tri"));
    if(Number.isNaN(idx) || !triCache[idx]) return;
    const k = inp.getAttribute("data-k");
    if(!k) return;
    triCache[idx][k] = inp.value;
    computeTriSums();
    autosaveSchedule("tri");
  });

  triRows.addEventListener("click", (e) => {
    const b = e.target.closest("button[data-action]");
    if(!b) return;
    if(b.getAttribute("data-action")==="del-tri"){
      const idx = Number(b.getAttribute("data-idx"));
      if(Number.isNaN(idx)) return;
      triCache.splice(idx, 1);
      renderTri();
      computeTriSums();
      autosaveSchedule("tri-del");
    }
  });

  triNameA.addEventListener("input", () => { computeTriSums(); autosaveSchedule("tri-names"); });
  triNameB.addEventListener("input", () => { computeTriSums(); autosaveSchedule("tri-names"); });
  triNameC.addEventListener("input", () => { computeTriSums(); autosaveSchedule("tri-names"); });

  addTriRowBtn.addEventListener("click", () => {
    triCache.push({ label:"", cat:"A", price:"", qty:"1" });
    renderTri();
    computeTriSums();
    autosaveSchedule("tri-add");
  });

  applyTriBtn.addEventListener("click", () => {
    autoSuggestTri();
  });

  // ----------------------------
  // Viewer open/parse pipeline
  // ----------------------------
  function refreshTags(){
    const f = viewerData?.fields || {};
    tags.innerHTML = `
      <span class="pill"># ${escapeHtml(f.numero_facture || "")}</span>
      <span class="pill">üìÖ ${escapeHtml(f.date_facture || "")}</span>
      <span class="pill">üë§ ${escapeHtml(f.client_nom || "")}</span>
      <span class="pill">HT ${escapeHtml(f.total_ht!=null ? String(f.total_ht) : "")}</span>
      <span class="pill">TTC ${escapeHtml(f.total_ttc!=null ? String(f.total_ttc) : "")}</span>
    `;
  }

  async function openViewerByIndex(idx){
    const it = state.files[idx];
    if(!it.factureId) return;

    const { data, error } = await sb.from("factures")
      .select("id,fichier_nom,statut,texte_ocr,created_at,donnees_brutes,fichier_url")
      .eq("id", it.factureId)
      .single();
    if(error){
      setMsg("err", "Erreur lecture: " + error.message);
      return;
    }

    viewerFactureId = data.id;
    viewerRawText = (data.texte_ocr || "").trim();
    viewerData = data.donnees_brutes || null;

    meta.innerHTML = `
      <span class="mono">ID ${escapeHtml(data.id)}</span> ‚Ä¢
      ${escapeHtml(data.fichier_nom || "")} ‚Ä¢
      Statut: <strong>${escapeHtml(data.statut || "")}</strong> ‚Ä¢
      Cr√©√©: ${escapeHtml(data.created_at || "")}
    `;

    // If donnees_brutes missing OR not enough fields OR table empty -> reparse
    const needsFields = !viewerData?.fields || Object.keys(viewerData.fields||{}).length < 2;
    const needsTable = !viewerData?.table || (viewerData.table?.every(p => (p?.services?.length||0)===0));

    if((needsFields || needsTable) && viewerRawText.length > 30){
      const parsed = parseFieldsRobust(viewerRawText);
      // keep any existing if present
      viewerData = viewerData || { lines:[], table:[], fields:{}, matches:[], version:"" };
      viewerData.fields = { ...(viewerData.fields||{}), ...(parsed.fields||{}) };
      viewerData.matches = [ ...(viewerData.matches||[]), ...(parsed.matches||[]) ];
      viewerData.version = "parser_table_v265";
      viewerData.parsed_at = new Date().toISOString();

      // Ensure table exists: if empty -> fallback OCR from text
      if(needsTable){
        viewerData.table = [{
          page:0, cols: defaultCols(),
          debug: { headerFound:false, servicesDetected:0, auto:"viewer-repair" },
          services: [],
          debours:[]
        }];
        const fallbackPage = fallbackTableFromOCRText(viewerRawText);
        viewerData.table = [ fallbackPage ];
      }

      // Save repaired data immediately
      await sb.from("factures").update({
        donnees_brutes: viewerData,
        statut:"extracted",
        numero_facture: viewerData.fields.numero_facture || null,
        date_facture: viewerData.fields.date_facture || null,
        client_nom: viewerData.fields.client_nom || null,
        total_ht: normalizeNumber(viewerData.fields.total_ht) ?? null,
        total_tva: normalizeNumber(viewerData.fields.total_tva) ?? null,
        total_ttc: normalizeNumber(viewerData.fields.total_ttc) ?? null
      }).eq("id", viewerFactureId);
    }

    // Render viewer content
    refreshTags();
    renderViewerHeader();
    loadViewerLinesFromData();
    renderViewerLines();
    initTriFromLines();

    tableHtml.innerHTML = renderTableHtml(viewerData);

    const hl = getHighlightValues(viewerData);
    textHtml.innerHTML = renderHighlightedText(viewerRawText, hl);

    debugJson.textContent = JSON.stringify(viewerData, null, 2);

    autosaveInfo.textContent = "Pr√™t";
    setTab("edit");
    openModal();
  }

  reparseBtn.addEventListener("click", async () => {
    if(!viewerFactureId) return;
    if(!viewerRawText || viewerRawText.length<30){
      setMsg("warn", "Texte trop court pour re-parser.");
      return;
    }
    setMsg("warn", "üîÅ Re-parse en cours‚Ä¶");

    // Force robust fields parse
    const parsed = parseFieldsRobust(viewerRawText);
    viewerData.fields = { ...(viewerData.fields||{}), ...(parsed.fields||{}) };
    viewerData.matches = [ ...(viewerData.matches||[]), ...(parsed.matches||[]) ];
    viewerData.version = "parser_table_v265";
    viewerData.parsed_at = new Date().toISOString();

    // Force fallback OCR table if current table empty
    const empty = !viewerData.table || viewerData.table.every(p => (p?.services?.length||0)===0);
    if(empty){
      viewerData.table = [ fallbackTableFromOCRText(viewerRawText) ];
    }

    // Rebuild editor caches
    refreshTags();
    renderViewerHeader();
    loadViewerLinesFromData();
    renderViewerLines();
    initTriFromLines();

    tableHtml.innerHTML = renderTableHtml(viewerData);
    const hl = getHighlightValues(viewerData);
    textHtml.innerHTML = renderHighlightedText(viewerRawText, hl);
    debugJson.textContent = JSON.stringify(viewerData, null, 2);

    // Save
    await sb.from("factures").update({
      donnees_brutes: viewerData,
      statut:"extracted",
      numero_facture: viewerData.fields.numero_facture || null,
      date_facture: viewerData.fields.date_facture || null,
      client_nom: viewerData.fields.client_nom || null,
      total_ht: normalizeNumber(viewerData.fields.total_ht) ?? null,
      total_tva: normalizeNumber(viewerData.fields.total_tva) ?? null,
      total_ttc: normalizeNumber(viewerData.fields.total_ttc) ?? null
    }).eq("id", viewerFactureId);

    setMsg("ok", "‚úÖ Re-parse termin√©");
    setTimeout(()=>setMsg("", ""), 1200);
  });

  // ----------------------------
  // Upload pipeline
  // ----------------------------
  async function ensureLoggedIn(){
    const { data:{ user } } = await sb.auth.getUser();
    if(!user) throw new Error("Non connect√©");
    return user;
  }

  async function uploadAndProcessOne(item){
    item.status="uploading";
    item.error=null;
    renderList();

    try{
      await ensureLoggedIn();

      // upload to bucket factures
      const year = new Date().getFullYear();
      const ts = Date.now();
      const filename = `${ts}_${sanitizeFilename(item.file.name)}`;
      const path = `${year}/${filename}`;

      const { error: upErr, data: upData } = await sb.storage.from("factures").upload(path, item.file, {
        upsert:false, cacheControl:"3600", contentType:"application/pdf"
      });
      if(upErr) throw upErr;

      // create DB row
      const { data: row, error: insErr } = await sb.from("factures").insert({
        fichier_url: path,
        fichier_nom: item.file.name,
        statut:"pending",
        format_facture:"auto"
      }).select("id,created_at").single();
      if(insErr) throw insErr;

      item.factureId = row.id;
      item.createdAt = row.created_at || new Date().toISOString();
      item.status="extracting";
      renderList();

      // signed url -> array buffer
      const { data: signed, error: signErr } = await sb.storage.from("factures").createSignedUrl(path, 600);
      if(signErr) throw signErr;

      const res = await fetch(signed.signedUrl);
      if(!res.ok) throw new Error("Fetch PDF impossible");
      const arrayBuffer = await res.arrayBuffer();

      // Text extraction
      const fullText = await extractPdfTextFromArrayBuffer(arrayBuffer);
      if(!fullText || fullText.length<30) throw new Error("Texte extrait trop court");

      // Fields parse
      const parsed = parseFieldsRobust(fullText);
      const data = {
        lines: [],
        table: [],
        fields: parsed.fields || {},
        matches: parsed.matches || [],
        version: "parser_table_v265",
        parsed_at: new Date().toISOString()
      };

      // Try XY table detection (v2.2)
      let pagesXY = [];
      try{
        const pages = await extractPdfItemsXY(arrayBuffer);
        // extract table per page
        const tablePages = [];
        for(const pg of pages){
          const tpg = extractTableFromXY(pg.items);
          tablePages.push({
            page: pg.page,
            cols: tpg.cols,
            debug: tpg.debug,
            services: tpg.services,
            debours: tpg.debours
          });
        }
        data.table = tablePages;
        pagesXY = tablePages;
      }catch(e){
        console.warn("XY detector error:", e);
        data.table = [];
      }

      // If table empty -> fallback OCR
      const emptyTable = !data.table.length || data.table.every(p => (p?.services?.length||0)===0);
      if(emptyTable){
        const fallback = fallbackTableFromOCRText(fullText);
        data.table = [ fallback ];
      }

      // Save DB
      const payload = {
        texte_ocr: fullText,
        donnees_brutes: data,
        statut:"extracted",
        numero_facture: data.fields.numero_facture || null,
        date_facture: data.fields.date_facture || null,
        client_nom: data.fields.client_nom || null,
        total_ht: normalizeNumber(data.fields.total_ht) ?? null,
        total_tva: normalizeNumber(data.fields.total_tva) ?? null,
        total_ttc: normalizeNumber(data.fields.total_ttc) ?? null
      };
      const { error: updErr } = await sb.from("factures").update(payload).eq("id", item.factureId);
      if(updErr) throw updErr;

      // replace in list as saved
      state.files = state.files.map(f => {
        if(f === item){
          return {
            kind:"saved",
            fileName: item.file.name,
            size: item.file.size,
            status:"extracted",
            factureId: item.factureId,
            createdAt: item.createdAt,
            error: null
          };
        }
        return f;
      });

      renderList();
      setMsg("ok", "‚úÖ Extraction OK. Clique üëÅ Voir pour √©diter et contr√¥ler.");
      setTimeout(()=>setMsg("", ""), 1500);

    }catch(e){
      item.status="error";
      item.error = e?.message || String(e);
      renderList();
      setMsg("err", "Erreur: " + item.error);
    }
  }

  startBtn.addEventListener("click", async () => {
    setMsg("warn", "Extraction en cours‚Ä¶");
    const items = state.files.filter(x => x.kind==="local" && x.status==="ready");
    for(const it of items){
      await uploadAndProcessOne(it);
    }
    setMsg("ok", "‚úÖ Termin√©.");
    setTimeout(()=>setMsg("", ""), 1200);
  });

  // ----------------------------
  // Init
  // ----------------------------
  (async function init(){
    try{
      // worker pdfjs
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

      sb = await waitForSupabaseClient();

      // restore list
      restoreList();
      renderList();

      // auth
      await refreshSession();
      sb.auth.onAuthStateChange(async () => await refreshSession());
      startKeepAlive();

      if(!sessionOk){
        setMsg("warn", "Connecte-toi pour uploader.");
      } else {
        setMsg("", "");
      }
    }catch(e){
      console.error(e);
      setMsg("err", "Supabase non initialis√© / erreur init: " + (e?.message || e));
    }
  })();

})();
</script>
</body>
</html>
