<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Import Factures</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#fafafa; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 18px; background:#fff; border-bottom:1px solid #e5e5e5; position:sticky; top:0; z-index:100; flex-wrap:wrap; }
    .btn { cursor:pointer; border:1px solid #ddd; background:#fff; padding:10px 12px; border-radius:10px; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    main { max-width: 980px; margin: 18px auto; padding: 0 14px; }
    .card { background:#fff; border:1px solid #e5e5e5; border-radius:14px; padding:14px; margin-bottom:14px; }
    .drop { border:2px dashed #bbb; border-radius:14px; padding:22px; text-align:center; background:#fcfcfc; }
    .drop.drag { border-color:#333; background:#fff; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #eee; padding:10px 8px; text-align:left; font-size:14px; vertical-align:top; }
    th { font-size:12px; text-transform:uppercase; letter-spacing:.04em; color:#666; }
    .pill { display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; }
    .ok { border-color:#9ad39a; }
    .err { border-color:#ffb3b3; }
    .muted { color:#666; font-size:13px; }
    .row-actions { display:flex; gap:8px; flex-wrap:wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }
    .notice { background:#fff7d6; border:1px solid #f1d88a; padding:10px 12px; border-radius:12px; margin-bottom:14px; }
    .small { font-size:12px; }
    input[type="file"] { max-width: 100%; }
    .field { border:1px solid #ddd; border-radius:10px; padding:10px 12px; background:#fff; }
    .authBox { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .msg { padding:10px 12px; border-radius:12px; border:1px solid #e5e5e5; background:#fff; }
    .msg.ok { border-color:#9ad39a; background:#f2fff2; }
    .msg.err { border-color:#ffb3b3; background:#fff2f2; }
    .msg.warn { border-color:#f1d88a; background:#fff7d6; }

    /* Highlight */
    mark.hl { background:#ffe58f; padding:0 2px; border-radius:4px; }
    mark.hl[data-label] { border-bottom:2px solid #ffb300; cursor:help; }
    .hlBox { display:flex; gap:10px; flex-wrap:wrap; padding:10px 12px; border:1px solid #eee; border-radius:12px; background:#fafafa; margin:10px 0; }
    .hlTag { border:1px solid #ddd; border-radius:999px; padding:4px 8px; font-size:12px; background:#fff; }

    /* ‚úÖ Modal robust */
    #textModal { display:none; pointer-events:none; }
    #textModal.open { display:flex !important; pointer-events:auto; }

    /* ‚úÖ PDF Table */
    .tablePdf {
      width:100%;
      border-collapse: collapse;
      font-size:13px;
      background:#fff;
      border:1px solid #eee;
      border-radius:12px;
      overflow:hidden;
    }
    .tablePdf th, .tablePdf td {
      border-bottom:1px solid #eee;
      padding:8px 10px;
      vertical-align:top;
      white-space:nowrap;
    }
    .tablePdf td.desc { white-space:normal; min-width:420px; }
    .tablePdf th { background:#f7f7f7; font-size:12px; text-transform:uppercase; letter-spacing:.03em; }
    .rowDebours td { background:#fff7d6; font-weight:600; }
  </style>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>

<body>
<header>
  <div style="display:flex; align-items:center; gap:10px;">
    <button class="btn" id="backBtn">‚¨ÖÔ∏è Retour</button>
    <strong>üì§ Import Factures (Viewer + DB ‚Äúcomme Claude‚Äù)</strong>
  </div>

  <div class="authBox">
    <span class="muted" id="authStatus">Connexion‚Ä¶</span>
    <input class="field" id="emailInput" type="email" placeholder="Email" style="min-width:220px;">
    <input class="field" id="passInput" type="password" placeholder="Mot de passe" style="min-width:160px;">
    <button class="btn" id="loginBtn">Se connecter</button>
    <button class="btn" id="logoutBtn" disabled>Se d√©connecter</button>
  </div>
</header>

<main>
  <div class="notice">
    <div><strong>Mode ‚Äúcomme Claude‚Äù</strong> : reconstruction d‚Äôun tableau lisible (align√©) depuis X/Y PDF + parsing DB depuis ce tableau.</div>
    <div class="muted small">Services = colonnes stables ‚Ä¢ D√©bours = lignes sp√©ciales.</div>
  </div>

  <div id="globalMsg" class="msg warn" style="display:none; margin-bottom:14px;"></div>

  <div class="card">
    <div class="drop" id="dropZone">
      <div style="font-size:18px; margin-bottom:6px;">Glisse-d√©pose tes PDFs ici</div>
      <div class="muted">PDF uniquement ‚Ä¢ max 10 MB/fichier ‚Ä¢ max 20 fichiers</div>
      <div style="margin-top:12px;">
        <input type="file" id="fileInput" accept="application/pdf" multiple />
      </div>
    </div>
    <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
      <button class="btn" id="startUploadBtn" disabled>üöÄ Uploader & Traiter</button>
      <button class="btn" id="clearBtn" disabled>üßπ Vider la liste</button>
    </div>
  </div>

  <div class="card">
    <div style="display:flex; align-items:center; justify-content:space-between;">
      <strong>üìÑ Fichiers s√©lectionn√©s</strong>
      <span class="muted" id="selectedCount">0</span>
    </div>

    <div style="overflow:auto; margin-top:10px;">
      <table>
        <thead>
        <tr>
          <th>Fichier</th>
          <th>Taille</th>
          <th>Statut</th>
          <th>Facture ID</th>
          <th>Actions</th>
        </tr>
        </thead>
        <tbody id="filesTbody">
        <tr><td colspan="5" class="muted">Aucun fichier</td></tr>
        </tbody>
      </table>
    </div>
  </div>
</main>

<!-- ‚úÖ MODALE VIEWER (PLAC√âE AVANT LES SCRIPTS POUR √âVITER NULL) -->
<div id="textModal" style="
  position:fixed; inset:0; background:rgba(0,0,0,.5);
  align-items:center; justify-content:center; padding:18px; z-index:9999;">
  <div style="
    width:min(1100px, 96vw); max-height:88vh; background:#fff; border-radius:14px;
    border:1px solid #e5e5e5; overflow:hidden; display:flex; flex-direction:column;">
    <div style="display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid #eee;">
      <strong>üßæ Viewer (Texte + Tableau)</strong>
      <div style="display:flex; gap:8px;">
        <button class="btn" id="copyTextBtn">üìã Copier</button>
        <button class="btn" id="closeTextBtn">‚úñ Fermer</button>
      </div>
    </div>
    <div style="padding:12px 14px; overflow:auto;">
      <div class="muted" id="textMeta" style="margin-bottom:10px;"></div>
      <div id="hlBox" class="hlBox"></div>

      <div style="display:flex; gap:8px; margin-bottom:10px;">
        <button class="btn" id="tabTextBtn">üü¶ Texte</button>
        <button class="btn" id="tabTableBtn">üü© Tableau</button>
      </div>

      <div id="tableWrap" style="display:none;">
        <div class="muted small" style="margin-bottom:8px;">
          Tableau reconstruit depuis les positions PDF (services align√©s + d√©bours en lignes sp√©ciales).
        </div>
        <div id="tableContent" style="overflow:auto;"></div>
      </div>

      <div id="textWrap">
        <div id="textContent" style="
          white-space:pre-wrap; word-break:break-word;
          background:#fafafa; border:1px solid #eee; border-radius:12px;
          padding:12px; font-size:13px; line-height:1.35;"></div>
      </div>
    </div>
  </div>
</div>

<script src="./supabase-core.js"></script>
<script src="./supabase-services.js"></script>

<script>
  // ------------------------------------------------------------
  // UI helpers
  // ------------------------------------------------------------
  const MAX_FILES = 20;
  const MAX_SIZE = 10 * 1024 * 1024;

  function setMsg(type, text) {
    const box = document.getElementById("globalMsg");
    box.className = "msg " + (type || "warn");
    box.textContent = text || "";
    box.style.display = text ? "block" : "none";
  }

  function formatBytes(bytes) {
    if (bytes < 1024) return bytes + " B";
    const kb = bytes / 1024;
    if (kb < 1024) return kb.toFixed(1) + " KB";
    return (kb / 1024).toFixed(1) + " MB";
  }
  function isPdf(file) { return file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf"); }
  function sanitizeFilename(name) { return name.replace(/[^a-zA-Z0-9.\-_]/g, "_").replace(/_{2,}/g, "_"); }

  // ------------------------------------------------------------
  // Highlight utils (tol√©rant)
  // ------------------------------------------------------------
  function escapeHtml(s) {
    return (s || "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }
  function escapeRegex(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

  function highlightText(rawText, highlights) {
    let html = escapeHtml(rawText);

    const sorted = [...highlights].sort((a,b) => (b.value.length - a.value.length));
    for (const h of sorted) {
      let token = (h.value || "").trim();
      if (!token || token.length < 3) continue;

      token = token.replace(/‚Äô/g, "'");
      let tokenRegex = escapeRegex(token).replace(/\s+/g, "\\s+");
      tokenRegex = tokenRegex.replace(/=>/g, "(?:=>|>\\s*=>?|=\\s*>)");

      const re = new RegExp(tokenRegex.replace(/'/g, "['‚Äô]"), "g");
      html = html.replace(re, (m) =>
        `<mark class="hl" data-label="${escapeHtml(h.label)}" title="${escapeHtml(h.label)}">${escapeHtml(m)}</mark>`
      );
    }
    return html;
  }

  function renderHighlightsBox(data) {
    const box = document.getElementById("hlBox");
    if (!box) return;

    const tags = [];
    if (data.numero_facture) tags.push(`<span class="hlTag"># ${escapeHtml(String(data.numero_facture))}</span>`);
    if (data.date_facture) tags.push(`<span class="hlTag">üìÖ ${escapeHtml(String(data.date_facture))}</span>`);
    if (data.client_nom) tags.push(`<span class="hlTag">üë§ ${escapeHtml(String(data.client_nom))}</span>`);
    if (typeof data.total_ht === "number") tags.push(`<span class="hlTag">HT ${escapeHtml(String(data.total_ht))}</span>`);
    if (typeof data.total_ttc === "number") tags.push(`<span class="hlTag">TTC ${escapeHtml(String(data.total_ttc))}</span>`);
    box.innerHTML = tags.length ? tags.join(" ") : `<span class="muted">Aucune donn√©e structur√©e d√©tect√©e.</span>`;
  }

  function buildHighlightsFromDB(data) {
    const hl = [];
    if (data.numero_facture) hl.push({ label:"Num√©ro facture", value:String(data.numero_facture) });
    if (data.client_nom) hl.push({ label:"Client", value:String(data.client_nom) });

    const matches = data?.donnees_brutes?.matches || [];
    for (const m of matches) {
      if (!m?.value) continue;
      hl.push({ label: m.label, value: String(m.value) });
    }

    const seen = new Set();
    return hl.filter(x => {
      const key = x.label + "::" + x.value;
      if (seen.has(key)) return false;
      seen.add(key);
      return (x.value || "").trim().length >= 3;
    });
  }

  // ------------------------------------------------------------
  // Parsing helpers
  // ------------------------------------------------------------
  function normalizeNumber(str) {
    if (!str) return null;
    const n = str.replace(/\s/g, "").replace(",", ".");
    const val = parseFloat(n.replace(/[^0-9.]/g, ""));
    return Number.isFinite(val) ? val : null;
  }
  function parsePercent(str) {
    if (!str) return null;
    const m = str.match(/(\d{1,2})\s*%/);
    return m ? parseInt(m[1], 10) : null;
  }
  function parseFrenchDateAny(dateStr) {
    if (!dateStr) return null;

    const mNum = dateStr.match(/(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})/);
    if (mNum) {
      let d = parseInt(mNum[1],10), mo = parseInt(mNum[2],10), y = parseInt(mNum[3],10);
      if (y < 100) y += 2000;
      return `${y.toString().padStart(4,"0")}-${mo.toString().padStart(2,"0")}-${d.toString().padStart(2,"0")}`;
    }

    const months = { "janvier":1, "f√©vrier":2, "fevrier":2, "mars":3, "avril":4, "mai":5, "juin":6,
      "juillet":7, "ao√ªt":8, "aout":8, "septembre":9, "octobre":10, "novembre":11, "d√©cembre":12, "decembre":12 };

    const mTxt = dateStr.toLowerCase().match(/(\d{1,2})\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+(\d{4})/);
    if (mTxt) {
      const d = parseInt(mTxt[1],10);
      const mo = months[mTxt[2]];
      const y = parseInt(mTxt[3],10);
      if (!mo) return null;
      return `${y.toString().padStart(4,"0")}-${String(mo).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
    }
    return null;
  }

  function splitSourceDest(desc) {
    let source = null, destination = null;
    const mFromTo = desc.match(/de\s+(.+?)\s+√†\s+(.+)/i);
    if (mFromTo) { source = mFromTo[1].trim(); destination = mFromTo[2].trim(); }
    const mArrow = desc.match(/(.+?)\s*(?:=>|>\s*=>?|=\s*>)\s*(.+)/);
    if (mArrow) { source = source || mArrow[1].trim(); destination = destination || mArrow[2].trim(); }
    return { source_lieu: source, destination_lieu: destination };
  }

  // ------------------------------------------------------------
  // Parse facture header/totaux (depuis fullText)
  // ------------------------------------------------------------
  function parseInvoiceText(fullText) {
    const out = { version:"parser_v3_table", parsed_at:new Date().toISOString(), fields:{}, matches:[] };
    const t = fullText || "";

    const mFact = t.match(/\bFacture\s+([A-Z]{2,6}-\d{3,4}-\d{2,})\b/i) || t.match(/\bFACT-\d{4}-\d{2,}\b/);
    if (mFact) {
      const val = (mFact[1] || mFact[0]).trim();
      out.fields.numero_facture = val;
      out.matches.push({ label:"numero_facture", value: val, raw: mFact[0] });
    }

    const mDateTxt = t.match(/\b(\d{1,2}\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+\d{4})\b/i);
    if (mDateTxt) {
      const rawDate = mDateTxt[1].trim();
      const iso = parseFrenchDateAny(rawDate);
      if (iso) {
        out.fields.date_facture = iso;
        out.matches.push({ label:"date_facture", value: rawDate, raw: rawDate });
      }
    } else {
      const mDateNum = t.match(/\b(\d{1,2}[\/\-.]\d{1,2}[\/\-.]\d{2,4})\b/);
      if (mDateNum) {
        const rawDate = mDateNum[1].trim();
        const iso = parseFrenchDateAny(rawDate);
        if (iso) {
          out.fields.date_facture = iso;
          out.matches.push({ label:"date_facture", value: rawDate, raw: rawDate });
        }
      }
    }

    const mDest = t.match(/Destinataire\s+(.+?)\s{2,}(?:√Ä|A)\s*l'?attention/i) ||
                  t.match(/Destinataire\s+(.+?)\s{2,}Adresse/i) ||
                  t.match(/Destinataire\s+(.+?)\s{2,}Conditions/i);
    if (mDest) {
      const client = mDest[1].replace(/\s+/g," ").trim();
      if (client.length > 2 && client.length < 120) {
        out.fields.client_nom = client;
        out.matches.push({ label:"client_nom", value: client, raw: mDest[0] });
      }
    }

    const mTotals1 = t.match(/Total\s*HT\s+TVA\s*\(\s*\d+%\s*\)\s+Total\s*TTC\s+([0-9\s.,]+)\s*‚Ç¨?\s+([0-9\s.,]+)\s*‚Ç¨?\s+([0-9\s.,]+)\s*‚Ç¨/i);
    if (mTotals1) {
      const htRaw = mTotals1[1].trim();
      const tvaRaw = mTotals1[2].trim();
      const ttcRaw = mTotals1[3].trim();
      out.fields.total_ht = normalizeNumber(htRaw);
      out.fields.total_tva = normalizeNumber(tvaRaw);
      out.fields.total_ttc = normalizeNumber(ttcRaw);
      out.matches.push({ label:"total_ht", value: htRaw, raw: mTotals1[0] });
      out.matches.push({ label:"total_tva", value: tvaRaw, raw: mTotals1[0] });
      out.matches.push({ label:"total_ttc", value: ttcRaw, raw: mTotals1[0] });
    }

    const mTotals2 = t.match(/Total\s*HT\s+TVA\s*\(\s*\d+%\s*\)\s+Total\s*TTC\s+D√©bours\s+Total\s+√†\s+payer\s+([0-9\s.,]+)\s*‚Ç¨\s+([0-9\s.,]+)\s*‚Ç¨\s+([0-9\s.,]+)\s*‚Ç¨\s+([0-9\s.,]+)\s*‚Ç¨\s+([0-9\s.,]+)\s*‚Ç¨/i);
    if (mTotals2) {
      const htRaw = mTotals2[1].trim();
      const tvaRaw = mTotals2[2].trim();
      const ttcRaw = mTotals2[3].trim();
      const debRaw = mTotals2[4].trim();
      const payRaw = mTotals2[5].trim();
      out.fields.total_ht = normalizeNumber(htRaw);
      out.fields.total_tva = normalizeNumber(tvaRaw);
      out.fields.total_ttc = normalizeNumber(ttcRaw);
      out.fields.debours = normalizeNumber(debRaw);
      out.fields.total_a_payer = normalizeNumber(payRaw);
      out.matches.push({ label:"total_ht", value: htRaw, raw: mTotals2[0] });
      out.matches.push({ label:"total_tva", value: tvaRaw, raw: mTotals2[0] });
      out.matches.push({ label:"total_ttc", value: ttcRaw, raw: mTotals2[0] });
      out.matches.push({ label:"debours", value: debRaw, raw: mTotals2[0] });
      out.matches.push({ label:"total_a_payer", value: payRaw, raw: mTotals2[0] });
    }

    return out;
  }

  // ------------------------------------------------------------
  // ‚úÖ Table extraction from PDF positions (X/Y)
  // ------------------------------------------------------------
  function groupItemsIntoLines(items, yTolerance = 2.5) {
    const sorted = [...items].sort((a,b) => b.y - a.y);
    const lines = [];
    for (const it of sorted) {
      let line = lines.find(l => Math.abs(l.y - it.y) <= yTolerance);
      if (!line) { line = { y: it.y, items: [] }; lines.push(line); }
      line.items.push(it);
    }
    for (const l of lines) l.items.sort((a,b) => a.x - b.x);
    lines.sort((a,b) => b.y - a.y);
    return lines;
  }

  function detectServiceColumnsFromHeader(lines) {
    const header = lines.find(l => {
      const s = l.items.map(i => i.str).join(" ").toLowerCase();
      return s.includes("prix") && s.includes("quant") && s.includes("tva") && s.includes("total");
    });
    if (!header) return { xType: 0, xDesc: 90, xPU: 360, xQty: 470, xTVA: 540, xTotal: 610 };

    const getX = (kw) => {
      const it = header.items.find(i => i.str.toLowerCase().includes(kw));
      return it ? it.x : null;
    };
    const xPU = getX("prix") || 360;
    const xQty = getX("quant") || 470;
    const xTVA = getX("tva") || 540;
    const xTotal = getX("total") || 610;
    return { xType: 0, xDesc: 90, xPU, xQty, xTVA, xTotal };
  }

  function lineToRow(line, cols) {
    const cells = { type:"", desc:"", pu:"", qty:"", tva:"", total:"" };
    for (const it of line.items) {
      const x = it.x;
      const str = it.str;
      if (x < cols.xDesc) cells.type += (cells.type ? " " : "") + str;
      else if (x < cols.xPU) cells.desc += (cells.desc ? " " : "") + str;
      else if (x < cols.xQty) cells.pu += (cells.pu ? " " : "") + str;
      else if (x < cols.xTVA) cells.qty += (cells.qty ? " " : "") + str;
      else if (x < cols.xTotal) cells.tva += (cells.tva ? " " : "") + str;
      else cells.total += (cells.total ? " " : "") + str;
    }
    for (const k of Object.keys(cells)) cells[k] = cells[k].replace(/\s+/g," ").trim();
    return cells;
  }

  function extractPdfTableFromTextContent(textContent) {
    const items = textContent.items.map(it => ({
      str: it.str,
      x: it.transform[4],
      y: it.transform[5]
    })).filter(it => it.str && it.str.trim().length);

    const lines = groupItemsIntoLines(items, 2.5);
    const cols = detectServiceColumnsFromHeader(lines);

    const services = [];
    const debours = [];

    for (const l of lines) {
      const rawLine = l.items.map(i => i.str).join(" ").replace(/\s+/g," ").trim();
      if (!rawLine) continue;

      if (/d√©bours/i.test(rawLine)) {
        debours.push(rawLine);
        continue;
      }

      const row = lineToRow(l, cols);
      const isService = /service/i.test(row.type) && (row.total.includes("‚Ç¨") || row.pu.includes("‚Ç¨"));
      if (isService) services.push(row);
    }

    return { services, debours, cols };
  }

  function renderPdfTableHtml(services, debours) {
    let html = `<table class="tablePdf">
      <thead><tr>
        <th>Type</th><th>Description</th><th>PU HT</th><th>Qt√©</th><th>TVA</th><th>Total HT</th>
      </tr></thead><tbody>`;

    for (const r of services) {
      html += `<tr>
        <td>${escapeHtml(r.type)}</td>
        <td class="desc">${escapeHtml(r.desc)}</td>
        <td>${escapeHtml(r.pu)}</td>
        <td>${escapeHtml(r.qty)}</td>
        <td>${escapeHtml(r.tva)}</td>
        <td>${escapeHtml(r.total)}</td>
      </tr>`;
    }
    if (debours.length > 0) {
      html += `<tr class="rowDebours"><td colspan="6">D√©bours</td></tr>`;
      for (const d of debours) html += `<tr class="rowDebours"><td colspan="6">${escapeHtml(d)}</td></tr>`;
    }
    html += `</tbody></table>`;
    return html;
  }

  // ------------------------------------------------------------
  // ‚úÖ Parse LINES from TABLE for DB
  // ------------------------------------------------------------
  function parseLinesFromTable(tablePages, parserOut) {
    const lines = [];
    let idx = 1;

    const allServices = [];
    const allDeboursRaw = [];

    for (const p of (tablePages || [])) {
      if (p?.services) allServices.push(...p.services);
      if (p?.debours) allDeboursRaw.push(...p.debours);
    }

    for (const r of allServices) {
      const desc = (r.desc || "").trim();
      let dateRaw = null, heure = null, cleanDesc = desc;

      const mDH = desc.match(/(\d{2}\/\d{2}\/\d{4})\s*:\s*([0-9]{1,2}h[0-9]{0,2})\s*(.*)/);
      if (mDH) {
        dateRaw = mDH[1];
        heure = mDH[2];
        cleanDesc = (mDH[3] || "").trim() || desc.trim();
      }

      const dateIso = dateRaw ? parseFrenchDateAny(dateRaw) : null;
      const { source_lieu, destination_lieu } = splitSourceDest(cleanDesc);

      const pu = normalizeNumber(r.pu);
      const qty = parseInt((r.qty || "1").replace(/\D/g,""), 10) || 1;
      const tva = parsePercent(r.tva) || null;
      const total = normalizeNumber(r.total);

      const obj = {
        type: "service",
        ligne_numero: idx++,
        date_service_raw: dateRaw,
        date_service: dateIso,
        heure_service: heure,
        description_service: cleanDesc,
        source_lieu,
        destination_lieu,
        prix_unitaire_ht: pu,
        quantite: qty,
        tva,
        prix_total_ht: total,
        confidence: "high",
        source_text: JSON.stringify(r)
      };
      lines.push(obj);

      if (parserOut?.matches) {
        parserOut.matches.push({ label:"service_ligne", value: (dateRaw ? `${dateRaw} : ${heure || ""} ` : "") + cleanDesc, raw: cleanDesc });
        if (r.pu) parserOut.matches.push({ label:"service_pu", value: r.pu, raw: r.pu });
        if (r.total) parserOut.matches.push({ label:"service_total", value: r.total, raw: r.total });
      }
    }

    for (const raw of allDeboursRaw) {
      const mAmt = raw.match(/([0-9\s.,]+)\s*‚Ç¨\s*$/);
      const amountRaw = mAmt ? mAmt[1].trim() : null;
      const amount = amountRaw ? normalizeNumber(amountRaw) : null;
      const desc = amountRaw ? raw.replace(mAmt[0], "").replace(/\s+/g," ").trim() : raw.trim();

      const obj = {
        type: "debours",
        ligne_numero: idx++,
        date_service: null,
        heure_service: null,
        description_service: desc,
        source_lieu: null,
        destination_lieu: null,
        prix_unitaire_ht: null,
        quantite: null,
        tva: null,
        prix_total_ht: amount,
        confidence: "high",
        source_text: raw
      };
      lines.push(obj);

      if (parserOut?.matches) {
        parserOut.matches.push({ label:"debours_desc", value: desc, raw: raw });
        if (amountRaw) parserOut.matches.push({ label:"debours_montant", value: amountRaw, raw: raw });
      }
    }

    return lines;
  }

  // ------------------------------------------------------------
  // State + DOM
  // ------------------------------------------------------------
  const state = { files: [] };
  const dropZone = document.getElementById("dropZone");
  const fileInput = document.getElementById("fileInput");
  const startUploadBtn = document.getElementById("startUploadBtn");
  const clearBtn = document.getElementById("clearBtn");
  const filesTbody = document.getElementById("filesTbody");
  const selectedCount = document.getElementById("selectedCount");

  const authStatus = document.getElementById("authStatus");
  const loginBtn = document.getElementById("loginBtn");
  const logoutBtn = document.getElementById("logoutBtn");
  const emailInput = document.getElementById("emailInput");
  const passInput = document.getElementById("passInput");

  document.getElementById("backBtn").onclick = () => window.location.href = "index.html";

  async function waitForSupabaseClient() {
    for (let i = 0; i < 60; i++) {
      if (window.SupabaseClient) return window.SupabaseClient;
      await new Promise(r => setTimeout(r, 100));
    }
    throw new Error("SupabaseClient non initialis√© (timeout)");
  }

  let sb;

  (async () => {
    try {
      sb = await waitForSupabaseClient();
      if (window.pdfjsLib?.GlobalWorkerOptions) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc =
          "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      }
      initApp();
    } catch (e) {
      console.error(e);
      setMsg("err", "Supabase non initialis√©. Recharge la page.");
    }
  })();

  function initApp() {
    // --- Viewer DOM refs (now exist, modal is above scripts)
    const textModal = document.getElementById("textModal");
    const closeTextBtn = document.getElementById("closeTextBtn");
    const copyTextBtn = document.getElementById("copyTextBtn");
    const textMeta = document.getElementById("textMeta");
    const hlBox = document.getElementById("hlBox");
    const tabTextBtn = document.getElementById("tabTextBtn");
    const tabTableBtn = document.getElementById("tabTableBtn");
    const textWrap = document.getElementById("textWrap");
    const tableWrap = document.getElementById("tableWrap");
    const tableContent = document.getElementById("tableContent");
    const textContent = document.getElementById("textContent");

    function closeModal() {
      textModal.classList.remove("open");
      textContent.innerHTML = "";
      tableContent.innerHTML = "";
      hlBox.innerHTML = "";
    }

    closeTextBtn.onclick = closeModal;
    textModal.addEventListener("click", (e) => { if (e.target === textModal) closeModal(); });

    copyTextBtn.onclick = async () => {
      const plain = (textContent.textContent || "");
      await navigator.clipboard.writeText(plain);
      copyTextBtn.textContent = "‚úÖ Copi√©";
      setTimeout(() => copyTextBtn.textContent = "üìã Copier", 900);
    };

    function setTab(which) {
      if (which === "text") { textWrap.style.display = "block"; tableWrap.style.display = "none"; }
      else { textWrap.style.display = "none"; tableWrap.style.display = "block"; }
    }
    tabTextBtn.onclick = () => setTab("text");
    tabTableBtn.onclick = () => setTab("table");

    // --- Auth
    async function refreshAuthStatus() {
      const { data: { user } } = await sb.auth.getUser();
      if (user) {
        authStatus.textContent = "Connect√©: " + (user.email || user.id);
        logoutBtn.disabled = false;
        emailInput.style.display = "none";
        passInput.style.display = "none";
        loginBtn.style.display = "none";
        setMsg("", "");
      } else {
        authStatus.textContent = "Non connect√©";
        logoutBtn.disabled = true;
        emailInput.style.display = "";
        passInput.style.display = "";
        loginBtn.style.display = "";
        setMsg("warn", "Connecte-toi pour uploader (bucket priv√©).");
      }
      render();
    }

    loginBtn.onclick = async () => {
      const email = (emailInput.value || "").trim();
      const password = passInput.value || "";
      if (!email || !password) return setMsg("warn", "Email et mot de passe requis.");
      setMsg("warn", "Connexion‚Ä¶");
      const { error } = await sb.auth.signInWithPassword({ email, password });
      if (error) return setMsg("err", "Erreur login: " + error.message);
      passInput.value = "";
      await refreshAuthStatus();
      setMsg("ok", "‚úÖ Connect√©.");
    };

    logoutBtn.onclick = async () => { await sb.auth.signOut(); await refreshAuthStatus(); };
    sb.auth.onAuthStateChange(() => refreshAuthStatus());
    refreshAuthStatus();

    async function ensureLoggedIn() {
      const { data: { user } } = await sb.auth.getUser();
      if (!user) throw new Error("Non connect√©");
      return user;
    }

    // --- UI list
    function render() {
      selectedCount.textContent = String(state.files.length);
      const anyBusy = state.files.some(f => ["uploading","extracting"].includes(f.status));
      startUploadBtn.disabled = state.files.length === 0 || anyBusy;
      clearBtn.disabled = state.files.length === 0 || anyBusy;

      filesTbody.innerHTML = "";
      if (state.files.length === 0) {
        filesTbody.innerHTML = `<tr><td colspan="5" class="muted">Aucun fichier</td></tr>`;
        return;
      }

      for (let i = 0; i < state.files.length; i++) {
        const item = state.files[i];
        const pill = (() => {
          if (item.status === "ready") return `<span class="pill">pr√™t</span>`;
          if (item.status === "uploading") return `<span class="pill">upload‚Ä¶</span>`;
          if (item.status === "extracting") return `<span class="pill">traitement‚Ä¶</span>`;
          if (item.status === "extracted") return `<span class="pill ok">OK</span>`;
          if (item.status === "error") return `<span class="pill err">erreur</span>`;
          return `<span class="pill">${item.status}</span>`;
        })();

        filesTbody.insertAdjacentHTML("beforeend", `
          <tr>
            <td>${escapeHtml(item.file.name)}${item.error ? `<div class="muted" style="color:#b00020;">${escapeHtml(item.error)}</div>` : ""}</td>
            <td>${formatBytes(item.file.size)}</td>
            <td>${pill}</td>
            <td>${item.factureId ? `<span class="mono">${item.factureId}</span>` : `<span class="muted">‚Äî</span>`}</td>
            <td>
              <div class="row-actions">
                <button class="btn" data-action="remove" data-index="${i}" ${item.status==="uploading" ? "disabled":""}>Retirer</button>
                <button class="btn" data-action="view" data-index="${i}" ${item.status!=="extracted" ? "disabled":""}>üëÅ Voir</button>
              </div>
            </td>
          </tr>
        `);
      }

      filesTbody.querySelectorAll("button[data-action]").forEach(btn => {
        btn.onclick = async () => {
          const idx = Number(btn.getAttribute("data-index"));
          const action = btn.getAttribute("data-action");
          if (action === "remove") { state.files.splice(idx, 1); render(); return; }
          if (action === "view") { await openViewer(idx); return; }
        };
      });
    }

    function addFiles(fileList) {
      const incoming = Array.from(fileList);
      for (const file of incoming) {
        if (state.files.length >= MAX_FILES) break;
        if (!isPdf(file)) { state.files.push({ file, status:"error", error:"PDF uniquement" }); continue; }
        if (file.size > MAX_SIZE) { state.files.push({ file, status:"error", error:"Max 10MB" }); continue; }
        state.files.push({ file, status:"ready", error:null, factureId:null, uploadPath:null });
      }
      render();
    }

    fileInput.addEventListener("change", (e) => addFiles(e.target.files));
    dropZone.addEventListener("dragover", (e) => { e.preventDefault(); dropZone.classList.add("drag"); });
    dropZone.addEventListener("dragleave", () => dropZone.classList.remove("drag"));
    dropZone.addEventListener("drop", (e) => { e.preventDefault(); dropZone.classList.remove("drag"); if (e.dataTransfer?.files) addFiles(e.dataTransfer.files); });
    clearBtn.onclick = () => { state.files = []; render(); };

    async function uploadAndProcessOne(item) {
      item.status = "uploading"; item.error = null; render();
      try {
        await ensureLoggedIn();

        const year = new Date().getFullYear();
        const ts = Date.now();
        const filename = `${ts}_${sanitizeFilename(item.file.name)}`;
        const path = `${year}/${filename}`;

        const { data: up, error: upErr } = await sb.storage.from("factures").upload(path, item.file, {
          upsert:false, cacheControl:"3600", contentType:"application/pdf"
        });
        if (upErr) throw upErr;
        item.uploadPath = up.path;

        const { data: inserted, error: dbErr } = await sb
          .from("factures")
          .insert({ fichier_url: up.path, fichier_nom: item.file.name, statut:"pending", format_facture:"moderne" })
          .select("id")
          .single();
        if (dbErr) throw dbErr;
        item.factureId = inserted.id;

        item.status = "extracting"; render();
        await extractParseSaveAndInsert(item);

        item.status = "extracted"; render();
      } catch (err) {
        item.status = "error";
        item.error = err?.message || String(err);
        render();
        if (item.factureId) await sb.from("factures").update({ statut:"error", error_message:item.error }).eq("id", item.factureId);
      }
    }

    async function extractParseSaveAndInsert(item) {
      const { data: signed, error: signErr } = await sb.storage.from("factures").createSignedUrl(item.uploadPath, 60*10);
      if (signErr) throw signErr;

      const res = await fetch(signed.signedUrl);
      if (!res.ok) throw new Error("T√©l√©chargement PDF impossible");
      const arrayBuffer = await res.arrayBuffer();

      const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;

      let fullText = "";
      const tablePages = [];

      for (let p=1; p<=pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();

        fullText += `\n\n=== PAGE ${p} ===\n` + content.items.map(it => it.str).join(" ");

        const table = extractPdfTableFromTextContent(content);
        tablePages.push({ page: p, ...table });
      }

      fullText = fullText.trim();
      if (fullText.length < 30) throw new Error("Texte extrait vide/trop court (PDF scan ?)");

      const parsed = parseInvoiceText(fullText);

      parsed.table = tablePages;
      parsed.lines = parseLinesFromTable(tablePages, parsed);

      const payload = { texte_ocr: fullText, statut:"extracted", donnees_brutes: parsed };
      if (parsed?.fields?.numero_facture) payload.numero_facture = parsed.fields.numero_facture;
      if (parsed?.fields?.date_facture) payload.date_facture = parsed.fields.date_facture;
      if (parsed?.fields?.client_nom) payload.client_nom = parsed.fields.client_nom;
      if (typeof parsed?.fields?.total_ht === "number") payload.total_ht = parsed.fields.total_ht;
      if (typeof parsed?.fields?.total_tva === "number") payload.total_tva = parsed.fields.total_tva;
      if (typeof parsed?.fields?.total_ttc === "number") payload.total_ttc = parsed.fields.total_ttc;

      const { error: updErr } = await sb.from("factures").update(payload).eq("id", item.factureId);
      if (updErr) throw updErr;

      const services = parsed.lines.filter(l => l.type === "service");
      const debours = parsed.lines.filter(l => l.type === "debours");

      if (services.length > 0) {
        const rowsLF = services.map(l => ({
          facture_id: item.factureId,
          ligne_numero: l.ligne_numero,
          date_service: l.date_service,
          heure_service: l.heure_service,
          source_lieu: l.source_lieu,
          destination_lieu: l.destination_lieu,
          description_service: l.description_service,
          trajet_brut: l.description_service,
          prix_unitaire_ht: l.prix_unitaire_ht,
          quantite: l.quantite,
          prix_total_ht: l.prix_total_ht,
          tva: l.tva,
          flags: { confidence:l.confidence, source_text:l.source_text }
        }));

        const { error: lfErr } = await sb.from("lignes_factures").insert(rowsLF);
        if (lfErr) throw lfErr;

        const year = parsed?.fields?.date_facture ? parseInt(parsed.fields.date_facture.slice(0,4),10) : new Date().getFullYear();
        const rowsSAS = services.map(l => ({
          facture_id: item.factureId,
          annee: year,
          date_service: l.date_service,
          heure_service: l.heure_service,
          source_lieu: l.source_lieu,
          destination_lieu: l.destination_lieu,
          source_text: l.source_text,
          prix_unitaire_ht: l.prix_unitaire_ht,
          quantite: l.quantite,
          total_ht: l.prix_total_ht,
          tva: l.tva,
          flags: { confidence:l.confidence },
          status: "READY"
        }));

        const { error: sasErr } = await sb.from("import_factures_rows").insert(rowsSAS);
        if (sasErr) throw sasErr;
      }

      if (debours.length > 0) {
        const rowsDeb = debours.map(l => ({
          facture_id: item.factureId,
          ligne_numero: l.ligne_numero,
          date_service: null,
          heure_service: null,
          source_lieu: null,
          destination_lieu: null,
          description_service: "DEBOURS: " + l.description_service,
          trajet_brut: l.description_service,
          prix_unitaire_ht: null,
          quantite: null,
          prix_total_ht: l.prix_total_ht,
          tva: null,
          flags: { type:"debours", confidence:l.confidence, source_text:l.source_text }
        }));
        await sb.from("lignes_factures").insert(rowsDeb);
      }
    }

    async function openViewer(idx) {
      const item = state.files[idx];
      if (!item?.factureId) return;

      const { data, error } = await sb
        .from("factures")
        .select("id,fichier_nom,statut,texte_ocr,created_at,donnees_brutes,numero_facture,date_facture,total_ht,total_tva,total_ttc,client_nom")
        .eq("id", item.factureId)
        .single();
      if (error) return setMsg("err", "Erreur lecture: " + error.message);

      textMeta.innerHTML = `
        <div><strong>Facture ID :</strong> <span class="mono">${escapeHtml(data.id)}</span></div>
        <div><strong>Fichier :</strong> ${escapeHtml(data.fichier_nom || "‚Äî")}</div>
        <div><strong>Statut :</strong> <span class="mono">${escapeHtml(data.statut || "‚Äî")}</span></div>
        <div><strong>Cr√©√© le :</strong> ${escapeHtml(data.created_at || "‚Äî")}</div>
      `;

      renderHighlightsBox(data);
      setTab("text");
      textModal.classList.add("open");

      const tablePages = data?.donnees_brutes?.table || [];
      const servicesAll = [];
      const deboursAll = [];
      for (const p of tablePages) {
        if (p?.services) servicesAll.push(...p.services);
        if (p?.debours) deboursAll.push(...p.debours);
      }
      tableContent.innerHTML = (servicesAll.length || deboursAll.length)
        ? renderPdfTableHtml(servicesAll, deboursAll)
        : `<div class="muted">Aucun tableau stock√©. (R√©-import n√©cessaire pour anciennes factures)</div>`;

      textContent.innerHTML = "<i>Chargement‚Ä¶</i>";
      const rawText = (data.texte_ocr || "").trim();
      const highlights = buildHighlightsFromDB(data);
      requestAnimationFrame(() => {
        textContent.innerHTML = highlightText(rawText || "‚ö†Ô∏è Aucun texte.", highlights);
      });
    }

    startUploadBtn.onclick = async () => {
      try { await ensureLoggedIn(); } catch { return setMsg("warn", "Connecte-toi d‚Äôabord pour uploader."); }
      setMsg("warn", "Traitement en cours‚Ä¶");
      const toProcess = state.files.filter(f => f.status === "ready");
      for (const item of toProcess) await uploadAndProcessOne(item);

      const okCount = state.files.filter(f => f.status === "extracted").length;
      const errCount = state.files.filter(f => f.status === "error").length;
      if (errCount === 0) setMsg("ok", `‚úÖ Termin√© : ${okCount} facture(s) trait√©e(s).`);
      else setMsg("err", `‚ö†Ô∏è Termin√© : ${okCount} OK, ${errCount} erreurs.`);
    };

    render();
  }
</script>
</body>
</html>
