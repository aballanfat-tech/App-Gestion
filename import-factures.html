<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Import Factures</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#fafafa; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 18px; background:#fff; border-bottom:1px solid #e5e5e5; position:sticky; top:0; z-index:100; flex-wrap:wrap; }
    .btn { cursor:pointer; border:1px solid #ddd; background:#fff; padding:10px 12px; border-radius:10px; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    main { max-width: 980px; margin: 18px auto; padding: 0 14px; }
    .card { background:#fff; border:1px solid #e5e5e5; border-radius:14px; padding:14px; margin-bottom:14px; }
    .drop { border:2px dashed #bbb; border-radius:14px; padding:22px; text-align:center; background:#fcfcfc; }
    .drop.drag { border-color:#333; background:#fff; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #eee; padding:10px 8px; text-align:left; font-size:14px; vertical-align:top; }
    th { font-size:12px; text-transform:uppercase; letter-spacing:.04em; color:#666; }
    .pill { display:inline-block; padding:4px 8px; border-radius:999px; border:1px solid #ddd; font-size:12px; }
    .ok { border-color:#9ad39a; }
    .err { border-color:#ffb3b3; }
    .muted { color:#666; font-size:13px; }
    .row-actions { display:flex; gap:8px; flex-wrap:wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }
    .notice { background:#fff7d6; border:1px solid #f1d88a; padding:10px 12px; border-radius:12px; margin-bottom:14px; }
    .small { font-size:12px; }
    input[type="file"] { max-width: 100%; }
    .field { border:1px solid #ddd; border-radius:10px; padding:10px 12px; background:#fff; }
    .authBox { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .msg { padding:10px 12px; border-radius:12px; border:1px solid #e5e5e5; background:#fff; }
    .msg.ok { border-color:#9ad39a; background:#f2fff2; }
    .msg.err { border-color:#ffb3b3; background:#fff2f2; }
    .msg.warn { border-color:#f1d88a; background:#fff7d6; }

    /* ‚úÖ Highlight */
    mark.hl {
      background: #ffe58f;
      padding: 0 2px;
      border-radius: 4px;
    }
    mark.hl[data-label] {
      border-bottom: 2px solid #ffb300;
      cursor: help;
    }
    .hlBox {
      display:flex; gap:10px; flex-wrap:wrap;
      padding:10px 12px; border:1px solid #eee; border-radius:12px;
      background:#fafafa; margin:10px 0;
    }
    .hlTag {
      border:1px solid #ddd; border-radius:999px; padding:4px 8px; font-size:12px;
      background:#fff;
    }
  </style>

  <!-- ‚úÖ PDF.js (extraction texte pour PDF num√©riques) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>

<body>
  <header>
    <div style="display:flex; align-items:center; gap:10px;">
      <button class="btn" id="backBtn">‚¨ÖÔ∏è Retour</button>
      <strong>üì§ Import Factures (Upload + Extraction + Parsing auto)</strong>
    </div>

    <div class="authBox">
      <span class="muted" id="authStatus">Connexion‚Ä¶</span>

      <!-- Login inline (sans prompt) -->
      <input class="field" id="emailInput" type="email" placeholder="Email" style="min-width:220px;">
      <input class="field" id="passInput" type="password" placeholder="Mot de passe" style="min-width:160px;">
      <button class="btn" id="loginBtn">Se connecter</button>
      <button class="btn" id="logoutBtn" disabled>Se d√©connecter</button>
    </div>
  </header>

  <main>
    <div class="notice">
      <div><strong>Important :</strong> bucket <span class="mono">factures</span> = <strong>priv√©</strong> ‚Üí il faut √™tre connect√© pour uploader.</div>
      <div class="muted">
        Apr√®s upload : extraction texte PDF automatique ‚Üí parsing automatique ‚Üí DB remplie
        (<span class="mono">donnees_brutes</span> + colonnes principales).
      </div>
      <div class="muted small" style="margin-top:6px;">‚ö†Ô∏è Si un PDF est un scan (image), l‚Äôextraction native peut √™tre vide ‚Üí on ajoutera un fallback OCR plus tard.</div>
    </div>

    <!-- Zone message globale (sans popup) -->
    <div id="globalMsg" class="msg warn" style="display:none; margin-bottom:14px;"></div>

    <div class="card">
      <div class="drop" id="dropZone">
        <div style="font-size:18px; margin-bottom:6px;">Glisse-d√©pose tes PDFs ici</div>
        <div class="muted">PDF uniquement ‚Ä¢ max 10 MB/fichier ‚Ä¢ max 20 fichiers</div>
        <div style="margin-top:12px;">
          <input type="file" id="fileInput" accept="application/pdf" multiple />
        </div>
      </div>
      <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn" id="startUploadBtn" disabled>üöÄ Uploader & Traiter</button>
        <button class="btn" id="clearBtn" disabled>üßπ Vider la liste</button>
      </div>
    </div>

    <div class="card">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <strong>üìÑ Fichiers s√©lectionn√©s</strong>
        <span class="muted" id="selectedCount">0</span>
      </div>

      <div style="overflow:auto; margin-top:10px;">
        <table>
          <thead>
            <tr>
              <th>Fichier</th>
              <th>Taille</th>
              <th>Statut</th>
              <th>Facture ID</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="filesTbody">
            <tr><td colspan="5" class="muted">Aucun fichier</td></tr>
          </tbody>
        </table>
      </div>

      <p class="muted" style="margin-top:10px;">
        <span class="mono">üëÅ Voir texte</span> affiche le texte enregistr√© + surlignage des champs reconnus.
      </p>
    </div>
  </main>

  <!-- ‚úÖ Option 2 stable : core + services -->
  <script src="./supabase-core.js"></script>
  <script src="./supabase-services.js"></script>

  <script>
    // -----------------------------
    // Helpers
    // -----------------------------
    const MAX_FILES = 20;
    const MAX_SIZE = 10 * 1024 * 1024;

    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + " B";
      const kb = bytes / 1024;
      if (kb < 1024) return kb.toFixed(1) + " KB";
      return (kb / 1024).toFixed(1) + " MB";
    }
    function isPdf(file) {
      return file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
    }
    function sanitizeFilename(name) {
      return name.replace(/[^a-zA-Z0-9.\-_]/g, "_").replace(/_{2,}/g, "_");
    }

    function setMsg(type, text) {
      const box = document.getElementById("globalMsg");
      box.className = "msg " + (type || "warn");
      box.textContent = text || "";
      box.style.display = text ? "block" : "none";
    }

    // -----------------------------
    // Highlight helpers
    // -----------------------------
    function escapeHtml(s) {
      return (s || "").replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }
    function escapeRegex(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function highlightText(rawText, highlights) {
      let html = escapeHtml(rawText || "");
      const sorted = [...highlights].sort((a,b) => (b.value.length - a.value.length));
      for (const h of sorted) {
        const token = (h.value || "").trim();
        if (!token || token.length < 3) continue;
        const re = new RegExp(escapeRegex(token), "g");
        html = html.replace(re, (m) => `<mark class="hl" data-label="${escapeHtml(h.label)}" title="${escapeHtml(h.label)}">${escapeHtml(m)}</mark>`);
      }
      return html;
    }

    function renderHighlightsBox(data, highlights) {
      const box = document.getElementById("hlBox");
      if (!box) return;
      const tags = [];

      if (data.numero_facture) tags.push(`<span class="hlTag"># ${escapeHtml(String(data.numero_facture))}</span>`);
      if (data.date_facture) tags.push(`<span class="hlTag">üìÖ ${escapeHtml(String(data.date_facture))}</span>`);
      if (data.client_nom) tags.push(`<span class="hlTag">üë§ ${escapeHtml(String(data.client_nom))}</span>`);

      if (typeof data.total_ht === "number") tags.push(`<span class="hlTag">HT ${escapeHtml(String(data.total_ht))}</span>`);
      if (typeof data.total_tva === "number") tags.push(`<span class="hlTag">TVA ${escapeHtml(String(data.total_tva))}</span>`);
      if (typeof data.total_ttc === "number") tags.push(`<span class="hlTag">TTC ${escapeHtml(String(data.total_ttc))}</span>`);

      if (!tags.length) {
        box.innerHTML = `<span class="muted">Aucune donn√©e structur√©e d√©tect√©e (parser).</span>`;
      } else {
        box.innerHTML = tags.join(" ");
      }
    }

    // -----------------------------
    // Parser V2 (adapt√© √† ton exemple)
    // -----------------------------
    function normalizeNumber(str) {
      if (!str) return null;
      // "2 050,00" -> 2050.00
      const n = String(str).replace(/\s/g, "").replace(",", ".");
      const val = parseFloat(n.replace(/[^0-9.]/g, ""));
      return Number.isFinite(val) ? val : null;
    }

    function parseFrenchDateAny(str) {
      // supporte:
      // - "17 f√©vrier 2025"
      // - "17 fevrier 2025"
      // - "17/02/2025"
      if (!str) return null;

      // 1) dd/mm/yyyy
      const m1 = String(str).match(/(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})/);
      if (m1) {
        let d = parseInt(m1[1],10), mo = parseInt(m1[2],10), y = parseInt(m1[3],10);
        if (y < 100) y += 2000;
        return `${y.toString().padStart(4,"0")}-${mo.toString().padStart(2,"0")}-${d.toString().padStart(2,"0")}`;
      }

      // 2) "17 f√©vrier 2025"
      const months = {
        "janvier":1, "fevrier":2, "f√©vrier":2, "mars":3, "avril":4, "mai":5, "juin":6,
        "juillet":7, "aout":8, "ao√ªt":8, "septembre":9, "octobre":10, "novembre":11,
        "decembre":12, "d√©cembre":12
      };

      const m2 = String(str).toLowerCase().match(/\b(\d{1,2})\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+(\d{4})\b/);
      if (!m2) return null;

      const d = parseInt(m2[1],10);
      const mo = months[m2[2]];
      const y = parseInt(m2[3],10);
      if (!mo) return null;

      return `${y.toString().padStart(4,"0")}-${String(mo).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
    }

    function findLastMatch(text, regex) {
      // retourne le dernier match trouv√©
      let last = null;
      const re = new RegExp(regex.source, regex.flags.includes("g") ? regex.flags : (regex.flags + "g"));
      let m;
      while ((m = re.exec(text)) !== null) last = m;
      return last;
    }

    function parseInvoiceText(text) {
      const t = text || "";
      const out = {
        version: "parser_v2_ballanfat",
        parsed_at: new Date().toISOString(),
        fields: {},
        matches: [] // {label, value, raw}
      };

      // ‚úÖ Num√©ro facture : "Facture FACT-2502-004"
      const mFact = t.match(/\bFacture\s+([A-Z0-9][A-Z0-9\-\/]{3,})\b/i);
      if (mFact) {
        out.fields.numero_facture = mFact[1].trim();
        out.matches.push({ label:"Num√©ro facture", value: mFact[1].trim(), raw: mFact[0] });
      }

      // ‚úÖ Date facture : ex "17 f√©vrier 2025" (juste apr√®s le num√©ro dans la m√™me zone)
      const mDateLong = t.match(/\b(\d{1,2}\s+(?:janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+\d{4})\b/i);
      if (mDateLong) {
        const iso = parseFrenchDateAny(mDateLong[1]);
        if (iso) {
          out.fields.date_facture = iso;
          out.matches.push({ label:"Date facture", value: mDateLong[1], raw: mDateLong[1] });
        }
      } else {
        // fallback dd/mm/yyyy
        const mDate = t.match(/\b(\d{1,2}[\/\-.]\d{1,2}[\/\-.]\d{2,4})\b/);
        if (mDate) {
          const iso = parseFrenchDateAny(mDate[1]);
          if (iso) {
            out.fields.date_facture = iso;
            out.matches.push({ label:"Date facture", value: mDate[1], raw: mDate[1] });
          }
        }
      }

      // ‚úÖ Client destinataire : "Destinataire ... Conditions"
      // Dans ton texte, c'est une longue ligne : on prend le bloc entre "Destinataire" et "Conditions"
      const mDest = t.match(/\bDestinataire\s+(.+?)\s+Conditions\b/si);
      if (mDest) {
        const block = mDest[1].replace(/\s+/g, " ").trim();
        // on garde les ~80 premiers caract√®res comme "client"
        const client = block.length > 80 ? block.slice(0, 80).trim() : block;
        if (client.length > 2) {
          out.fields.client_nom = client;
          out.matches.push({ label:"Client", value: client, raw: "Destinataire " + client });
        }
      }

      // ‚úÖ Totaux : on prend le DERNIER match dans le texte (pour √©viter colonnes HT du tableau)
      const mHT  = findLastMatch(t, /Total\s*HT\s+([0-9\s.,]+)\s*(?:‚Ç¨|EUR)?/i);
      const mTVA = findLastMatch(t, /TVA\s*\(10%\)\s+([0-9\s.,]+)\s*(?:‚Ç¨|EUR)?/i);
      const mTTC = findLastMatch(t, /Total\s*TTC\s+([0-9\s.,]+)\s*(?:‚Ç¨|EUR)?/i);

      if (mHT)  { out.fields.total_ht  = normalizeNumber(mHT[1]);  out.matches.push({label:"Total HT",  value:mHT[1].trim(), raw:mHT[0]}); }
      if (mTVA) { out.fields.total_tva = normalizeNumber(mTVA[1]); out.matches.push({label:"TVA (10%)", value:mTVA[1].trim(), raw:mTVA[0]}); }
      if (mTTC) { out.fields.total_ttc = normalizeNumber(mTTC[1]); out.matches.push({label:"Total TTC", value:mTTC[1].trim(), raw:mTTC[0]}); }

      return out;
    }

    function buildHighlightsFromParsed(parsed) {
      const hl = [];
      if (!parsed) return hl;
      // surligner les valeurs captur√©es exactement
      for (const m of (parsed.matches || [])) {
        if (!m?.value) continue;
        hl.push({ label: m.label || "match", value: String(m.value) });
      }
      // d√©dupe
      const seen = new Set();
      return hl.filter(x => {
        const key = x.label + "::" + x.value;
        if (seen.has(key)) return false;
        seen.add(key);
        return x.value.length >= 3;
      });
    }

    // -----------------------------
    // State
    // -----------------------------
    const state = { files: [] };

    // -----------------------------
    // UI
    // -----------------------------
    const dropZone = document.getElementById("dropZone");
    const fileInput = document.getElementById("fileInput");
    const startUploadBtn = document.getElementById("startUploadBtn");
    const clearBtn = document.getElementById("clearBtn");
    const filesTbody = document.getElementById("filesTbody");
    const selectedCount = document.getElementById("selectedCount");

    const authStatus = document.getElementById("authStatus");
    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const emailInput = document.getElementById("emailInput");
    const passInput = document.getElementById("passInput");

    document.getElementById("backBtn").onclick = () => {
      window.location.href = "index.html";
    };

    // -----------------------------
    // Wait Supabase
    // -----------------------------
    async function waitForSupabaseClient() {
      for (let i = 0; i < 60; i++) {
        if (window.SupabaseClient) return window.SupabaseClient;
        await new Promise(r => setTimeout(r, 100));
      }
      throw new Error("SupabaseClient non initialis√© (timeout)");
    }

    let sb;

    // Init app when Supabase ready
    (async () => {
      try {
        sb = await waitForSupabaseClient();

        // PDF.js worker
        if (window.pdfjsLib?.GlobalWorkerOptions) {
          window.pdfjsLib.GlobalWorkerOptions.workerSrc =
            "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
        }

        initApp();
      } catch (e) {
        console.error(e);
        setMsg("err", "Supabase non initialis√©. Recharge la page.");
      }
    })();

    // -----------------------------
    // App
    // -----------------------------
    function initApp() {

      // Auth
      async function refreshAuthStatus() {
        const { data: { user } } = await sb.auth.getUser();
        if (user) {
          authStatus.textContent = "Connect√©: " + (user.email || user.id);
          logoutBtn.disabled = false;

          emailInput.style.display = "none";
          passInput.style.display = "none";
          loginBtn.style.display = "none";
          setMsg("", "");
        } else {
          authStatus.textContent = "Non connect√©";
          logoutBtn.disabled = true;

          emailInput.style.display = "";
          passInput.style.display = "";
          loginBtn.style.display = "";
          setMsg("warn", "Connecte-toi pour uploader dans le bucket priv√©.");
        }
        render();
      }

      loginBtn.onclick = async () => {
        try {
          const email = (emailInput.value || "").trim();
          const password = passInput.value || "";
          if (!email || !password) {
            setMsg("warn", "Email et mot de passe requis.");
            return;
          }

          setMsg("warn", "Connexion en cours‚Ä¶");
          const { error } = await sb.auth.signInWithPassword({ email, password });
          if (error) {
            setMsg("err", "Erreur login: " + error.message);
            return;
          }
          passInput.value = "";
          await refreshAuthStatus();
          setMsg("ok", "‚úÖ Connect√©.");
        } catch (e) {
          setMsg("err", "Erreur login: " + (e?.message || e));
        }
      };

      logoutBtn.onclick = async () => {
        await sb.auth.signOut();
        await refreshAuthStatus();
      };

      sb.auth.onAuthStateChange(() => refreshAuthStatus());
      refreshAuthStatus();

      async function ensureLoggedIn() {
        const { data: { user } } = await sb.auth.getUser();
        if (!user) throw new Error("Non connect√©");
        return user;
      }

      // Render
      function render() {
        selectedCount.textContent = String(state.files.length);

        const anyBusy = state.files.some(f => ["uploading","extracting","parsing"].includes(f.status));
        startUploadBtn.disabled = state.files.length === 0 || anyBusy;
        clearBtn.disabled = state.files.length === 0 || anyBusy;

        filesTbody.innerHTML = "";
        if (state.files.length === 0) {
          filesTbody.innerHTML = `<tr><td colspan="5" class="muted">Aucun fichier</td></tr>`;
          return;
        }

        for (let i = 0; i < state.files.length; i++) {
          const item = state.files[i];

          const statusPill = (() => {
            if (item.status === "ready") return `<span class="pill">pr√™t</span>`;
            if (item.status === "uploading") return `<span class="pill">upload‚Ä¶</span>`;
            if (item.status === "extracting") return `<span class="pill">extraction‚Ä¶</span>`;
            if (item.status === "parsing") return `<span class="pill">parsing‚Ä¶</span>`;
            if (item.status === "extracted") return `<span class="pill ok">extracted</span>`;
            if (item.status === "error") return `<span class="pill err">erreur</span>`;
            return `<span class="pill">${item.status}</span>`;
          })();

          const factureId = item.factureId ? `<span class="mono">${item.factureId}</span>` : `<span class="muted">‚Äî</span>`;

          filesTbody.insertAdjacentHTML("beforeend", `
            <tr>
              <td>
                ${item.file.name}
                ${item.error ? `<div class="muted" style="color:#b00020;">${item.error}</div>` : ""}
              </td>
              <td>${formatBytes(item.file.size)}</td>
              <td>${statusPill}</td>
              <td>${factureId}</td>
              <td>
                <div class="row-actions">
                  <button class="btn" ${item.status==="uploading" ? "disabled" : ""} data-action="remove" data-index="${i}">Retirer</button>
                  <button class="btn" ${item.status!=="extracted" ? "disabled" : ""} data-action="viewText" data-index="${i}">üëÅ Voir texte</button>
                </div>
              </td>
            </tr>
          `);
        }

        filesTbody.querySelectorAll("button[data-action]").forEach(btn => {
          btn.onclick = async () => {
            const idx = Number(btn.getAttribute("data-index"));
            const action = btn.getAttribute("data-action");

            if (action === "remove") {
              state.files.splice(idx, 1);
              render();
              return;
            }

            if (action === "viewText") {
              await openTextViewer(idx);
              return;
            }
          };
        });
      }

      // Add files
      function addFiles(fileList) {
        const incoming = Array.from(fileList);
        for (const file of incoming) {
          if (state.files.length >= MAX_FILES) break;
          if (!isPdf(file)) { state.files.push({ file, status:"error", error:"PDF uniquement" }); continue; }
          if (file.size > MAX_SIZE) { state.files.push({ file, status:"error", error:"Max 10MB" }); continue; }
          state.files.push({ file, status:"ready", error:null, factureId:null, uploadPath:null });
        }
        render();
      }

      fileInput.addEventListener("change", (e) => addFiles(e.target.files));
      dropZone.addEventListener("dragover", (e) => { e.preventDefault(); dropZone.classList.add("drag"); });
      dropZone.addEventListener("dragleave", () => dropZone.classList.remove("drag"));
      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.classList.remove("drag");
        if (e.dataTransfer?.files) addFiles(e.dataTransfer.files);
      });

      clearBtn.onclick = () => { state.files = []; render(); };

      // Upload + auto extract + auto parse
      async function uploadAndProcessOne(item) {
        item.status = "uploading";
        item.error = null;
        render();

        try {
          await ensureLoggedIn();

          // 1) Upload storage
          const year = new Date().getFullYear();
          const ts = Date.now();
          const filename = `${ts}_${sanitizeFilename(item.file.name)}`;
          const path = `${year}/${filename}`;

          const { data: up, error: upErr } = await sb
            .storage
            .from("factures")
            .upload(path, item.file, { upsert:false, cacheControl:"3600", contentType:"application/pdf" });

          if (upErr) throw upErr;
          item.uploadPath = up.path;

          // 2) Insert DB row
          const { data: inserted, error: dbErr } = await sb
            .from("factures")
            .insert({ fichier_url: up.path, fichier_nom: item.file.name, statut:"pending", format_facture:"moderne" })
            .select("id")
            .single();

          if (dbErr) throw dbErr;

          item.factureId = inserted.id;

          // 3) Extraction + parsing
          await extractAndParseForItem(item);

        } catch (err) {
          item.status = "error";
          item.error = err?.message || String(err);
          render();
        }
      }

      async function extractAndParseForItem(item) {
        item.status = "extracting";
        item.error = null;
        render();

        try {
          await ensureLoggedIn();

          // Signed URL
          const { data: signed, error: signErr } = await sb
            .storage
            .from("factures")
            .createSignedUrl(item.uploadPath, 60 * 10);

          if (signErr) throw signErr;

          // Fetch PDF
          const res = await fetch(signed.signedUrl);
          if (!res.ok) throw new Error("T√©l√©chargement PDF impossible (signed URL)");
          const arrayBuffer = await res.arrayBuffer();

          // Extract text
          const loadingTask = window.pdfjsLib.getDocument({ data: arrayBuffer });
          const pdf = await loadingTask.promise;

          let fullText = "";
          for (let p = 1; p <= pdf.numPages; p++) {
            const page = await pdf.getPage(p);
            const content = await page.getTextContent();
            const pageText = content.items.map(it => it.str).join(" ");
            fullText += `\n\n=== PAGE ${p} ===\n` + pageText;
          }

          fullText = fullText.trim();
          if (fullText.length < 30) {
            throw new Error("Texte extrait vide/trop court (PDF scan ?)");
          }

          item.status = "parsing";
          render();

          // Parse
          const parsed = parseInvoiceText(fullText);

          // Build payload
          const payload = {
            texte_ocr: fullText,
            statut: "extracted",
            donnees_brutes: parsed
          };

          if (parsed?.fields?.numero_facture) payload.numero_facture = parsed.fields.numero_facture;
          if (parsed?.fields?.date_facture) payload.date_facture = parsed.fields.date_facture;
          if (parsed?.fields?.client_nom) payload.client_nom = parsed.fields.client_nom;

          if (typeof parsed?.fields?.total_ht === "number") payload.total_ht = parsed.fields.total_ht;
          if (typeof parsed?.fields?.total_tva === "number") payload.total_tva = parsed.fields.total_tva;
          if (typeof parsed?.fields?.total_ttc === "number") payload.total_ttc = parsed.fields.total_ttc;

          // Save
          const { error: updErr } = await sb
            .from("factures")
            .update(payload)
            .eq("id", item.factureId);

          if (updErr) throw updErr;

          item.status = "extracted";
          render();

        } catch (err) {
          item.status = "error";
          item.error = err?.message || String(err);
          render();

          if (item.factureId) {
            await sb.from("factures")
              .update({ statut:"error", error_message:item.error })
              .eq("id", item.factureId);
          }
        }
      }

      startUploadBtn.onclick = async () => {
        try {
          await ensureLoggedIn();
        } catch {
          setMsg("warn", "Connecte-toi d‚Äôabord pour uploader.");
          return;
        }

        setMsg("warn", "Traitement en cours : upload + extraction + parsing automatiques‚Ä¶");
        const toProcess = state.files.filter(f => f.status === "ready");

        for (const item of toProcess) {
          await uploadAndProcessOne(item);
        }

        const okCount = state.files.filter(f => f.status === "extracted").length;
        const errCount = state.files.filter(f => f.status === "error").length;

        if (errCount === 0) setMsg("ok", `‚úÖ Termin√© : ${okCount} facture(s) trait√©e(s).`);
        else setMsg("err", `‚ö†Ô∏è Termin√© : ${okCount} OK, ${errCount} en erreur (voir colonne fichier).`);
      };

      // Viewer (modale)
      const textModal = document.getElementById("textModal");
      const closeTextBtn = document.getElementById("closeTextBtn");
      const copyTextBtn = document.getElementById("copyTextBtn");
      const textContent = document.getElementById("textContent");
      const textMeta = document.getElementById("textMeta");

      closeTextBtn.onclick = () => { textModal.style.display = "none"; };
      textModal.addEventListener("click", (e) => { if (e.target === textModal) textModal.style.display = "none"; });

      copyTextBtn.onclick = async () => {
        try {
          // Copie du texte brut (sans balises)
          const tmp = document.createElement("div");
          tmp.innerHTML = textContent.innerHTML;
          const plain = tmp.textContent || "";
          await navigator.clipboard.writeText(plain);
          copyTextBtn.textContent = "‚úÖ Copi√©";
          setTimeout(() => (copyTextBtn.textContent = "üìã Copier"), 900);
        } catch {
          setMsg("warn", "Copie impossible (permission navigateur).");
        }
      };

      async function openTextViewer(idx) {
        const item = state.files[idx];
        if (!item?.factureId) return;

        try {
          const { data, error } = await sb
            .from("factures")
            .select("id,fichier_nom,statut,texte_ocr,created_at,donnees_brutes,numero_facture,date_facture,total_ht,total_tva,total_ttc,client_nom")
            .eq("id", item.factureId)
            .single();

          if (error) throw error;

          textMeta.innerHTML = `
            <div><strong>Facture ID :</strong> <span class="mono">${escapeHtml(data.id)}</span></div>
            <div><strong>Fichier :</strong> ${escapeHtml(data.fichier_nom || "‚Äî")}</div>
            <div><strong>Statut :</strong> <span class="mono">${escapeHtml(data.statut || "‚Äî")}</span></div>
            <div><strong>Cr√©√© le :</strong> ${escapeHtml(data.created_at || "‚Äî")}</div>
          `;

          const parsed = data.donnees_brutes || null;
          const highlights = buildHighlightsFromParsed(parsed);

          renderHighlightsBox(data, highlights);

          const rawText = (data.texte_ocr || "").trim();
          textContent.innerHTML = highlightText(rawText, highlights);

          textModal.style.display = "flex";
        } catch (e) {
          setMsg("err", "Erreur lecture texte: " + (e?.message || e));
        }
      }

      // Initial render
      render();
    }
  </script>

  <!-- ‚úÖ MODALE : Viewer du texte extrait -->
  <div id="textModal" style="
    display:none; position:fixed; inset:0; background:rgba(0,0,0,.5);
    align-items:center; justify-content:center; padding:18px; z-index:9999;">
    <div style="
      width:min(980px, 95vw); max-height:85vh; background:#fff; border-radius:14px;
      border:1px solid #e5e5e5; overflow:hidden; display:flex; flex-direction:column;">
      <div style="display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid #eee;">
        <strong>üßæ Texte extrait + surlignage</strong>
        <div style="display:flex; gap:8px;">
          <button class="btn" id="copyTextBtn">üìã Copier</button>
          <button class="btn" id="closeTextBtn">‚úñ Fermer</button>
        </div>
      </div>
      <div style="padding:12px 14px; overflow:auto;">
        <div class="muted" id="textMeta" style="margin-bottom:10px;"></div>

        <!-- ‚úÖ R√©sum√© champs extraits -->
        <div id="hlBox" class="hlBox"></div>

        <!-- ‚úÖ Texte (HTML) -->
        <div id="textContent" style="
          white-space:pre-wrap; word-break:break-word;
          background:#fafafa; border:1px solid #eee; border-radius:12px;
          padding:12px; font-size:13px; line-height:1.35;"></div>
      </div>
    </div>
  </div>
</body>
</html>
